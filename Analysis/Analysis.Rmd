---
title: "Longitudinal gameplay and well-being"
author:
  - name: <a href="https://vuorre.netlify.app">Matti Vuorre</a>
    affiliation: <a href="https://www.oii.ox.ac.uk/people/matti-vuorre/">University of Oxford</a>
  - name: Your Name Here
    affiliation: University
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    theme: yeti
    highlight: kate
    self_contained: true
    number_sections: false
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r packages, include = FALSE}
library(knitr)
library(scales)
library(janitor)
library(ggbeeswarm)
library(gtsummary)
library(bayestestR)
library(brms)
library(tidybayes)
library(broom)
library(here)
library(lubridate)
library(naniar)
library(ggtext)
library(emmeans)
library(ggstance)
library(ggdist)
library(patchwork)
library(readxl)
library(lavaan)
library(GGally)
# remotes::install_github("jflournoy/riclpmr")  
library(riclpmr)
library(ggnewscale)
library(showtext)
library(tidyverse)
library(multidplyr)
```

```{r setup, include=FALSE}

# parallel computations
cluster <- new_cluster(8)
# load packages on clusters
cluster_library(cluster, c("dplyr", "lavaan"))


# Knitr options
opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  cache = TRUE,
  error = FALSE,
  message = FALSE,
  fig.align = "center",
  fig.retina = 2
)
# Plotting options
Font <- "Titillium Web"
font_add_google(Font, Font)
theme_set(
  theme_linedraw(
    base_family = Font, 
    base_size = 12) +
    theme(
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank()
    )
)
# MCMC settings
options(mc.cores = 1)
if (require("cmdstanr")) options(brms.backend = "cmdstanr")

# Run this to delete fitted models and refit
# unlink(list.files(pattern = "brm-.*\\.rds"))
```

# Preface

This document contains the analyses supporting "A longitudinal study of video game play and well-being" <doi>

```{r}
data_path <- here("Data", "cleaned_data.Rds")
if(file.exists(data_path)) {
d <- readRDS(file = data_path)
} else {
    stop("'Data/cleaned_data.Rds' doesn't exist, run `Analysis/data_cleaning.Rmd` to create it.")
}
```

# Univariate analyses

## Key variables over time

Note that `played` variable is not useful; it was not collected in waves 2 and 3, and sometimes people did estimate to have time played even though reported not playing :/ 

```{r}
d %>%
  mutate(Hours_over_40 = Hours > 40) %>%
  tabyl(Hours_over_40) %>%
  adorn_pct_formatting()
tmp <- d %>%
  select(
    Game, Wave, pid,
    Hours, CSAS, SPANE,
    Enjoyment, Extrinsic, Needs
  ) %>%
  pivot_longer(Hours:Needs) %>%
  drop_na(value) %>%
  filter(value <= 40) %>%
  mutate(
    name = factor(
      name,
      levels = c("Hours", "SPANE", "CSAS", "Extrinsic", "Enjoyment", "Needs"),
      labels = c("Hours played", "Affect", "Life satisfaction", "Extrinsic motivation", "Intrinsic motivation", "Needs satisfaction")
    )
  )
tmp %>%
  # Order points from low to high value within panel and wave
  # so dodging doesn't look like a mess.
  mutate(within_panel_wave_order = str_glue("{name}.{Game}.{Wave}")) %>%
  group_by(name, Wave, Game) %>%
  mutate(mv = mean(value, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(name, Wave, mv) %>%
  mutate(within_panel_wave_order = fct_inorder(within_panel_wave_order)) %>%
  ggplot(
    aes(
      Wave, value,
      fill = Game, col = Game, group = within_panel_wave_order
    )
  ) +
  scale_x_discrete(labels = 1:3, expand = expansion(c(0.1, .1))) +
  scale_color_brewer(palette = "Set1", aesthetics = c("fill", "color")) +
  scale_y_continuous(
    breaks = pretty_breaks(),
    expand = expansion(.025)
  ) +
  geom_blank() +
  stat_halfeye(
    alpha = .2, height = .02, normalize = "panels", adjust = 1.1,
    point_interval = NULL, show.legend = FALSE,
    position = position_nudge(x = .05)
  ) +
  stat_summary(
    fun.data = mean_cl_normal, fatten = 1,
    position = position_dodge(.08)
  ) +
  facet_wrap("name", scales = "free_y", ncol = 3) +
  labs(y = "Value") +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),
    fill = guide_legend(nrow = 2, byrow = TRUE)
  ) +
  theme(
    legend.position = "bottom", 
    legend.justification = "left", 
    legend.margin = margin(l = -12),
    legend.title = element_blank(), 
    legend.text = element_text(margin = margin(l = -8), size = 8)
  )
ggsave(here("Output/Figures/Figure-1.png"), width = 5, height = 6)
```


### Kristoffer's alternative plot
A small multiple plot could work better, something like this. Could add some more color.
```{r}
tmp_plot <- tmp %>%
  # Order points from low to high value within panel and wave
  # so dodging doesn't look like a mess.
  mutate(within_panel_wave_order = str_glue("{name}.{Game}.{Wave}")) %>%
  group_by(name, Wave, Game) %>%
  mutate(mv = mean(value, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(name, Wave, mv) %>%
  mutate(within_panel_wave_order = fct_inorder(within_panel_wave_order))
  
tmp_wave_mean <- tmp_plot %>%
    group_by(Wave, Game, name) %>%
    summarize(y = mean(value))
col1 <- "#2980b9"
col2 <- "#2980b9"

tmp_plot %>%
  ggplot(
    aes(
      Wave, 
      value,
      fill = Game, 
      color, Game,
      group = Game
    )
  ) +
  scale_x_discrete(labels = 1:3, expand = expansion(c(0.1, .1))) +
  scale_color_manual(
      values = c(col1, col2, col1, col2, col1, col2, col1), 
      aesthetics = c("fill", "color", "slab_color")) +
  scale_y_continuous(
    breaks = pretty_breaks(),
    expand = expansion(.025)
  ) +
  geom_blank() +
    stat_halfeye(
    alpha = .33,
    height = .02,
    normalize = "panels", 
    adjust = 1.1,
    point_interval = NULL, 
    show.legend = FALSE,
    #position = position_nudge(x = .05)
  ) +
  # only the outline (hackish)
    stat_halfeye(
    alpha = 1,
    height = .02,
    normalize = "panels", 
    aes(slab_color = Game),
    slab_size = 0.5,
    fill = NA,
    adjust = 1.1,
    point_interval = NULL, 
    show.legend = FALSE,
    #position = position_nudge(x = .05)
  ) +
  stat_summary(
    fun.data = mean_cl_normal, 
    fatten = 1.25
  ) +
  geom_line(
      data = tmp_wave_mean,
      aes(y = y, group = NA)
  ) +
  facet_grid(name ~ Game, scales = "free_y") +
  labs(y = "Value") +
  guides(color = guide_legend(nrow = 2, byrow = TRUE)) +
  theme(
      legend.position = "bottom",
      legend.title = element_blank()
    )
ggsave(here("Output/Figures/Figure-1-2.png"), width = 5, height = 6)

```


# Bivariate relations
```{r}
d %>%
  select(
    CSAS, SPANE, Needs, 
    Relatedness, Enjoyment, Extrinsic, Hours, hours_est
  ) %>%
  psych::cor.plot(
    scale = FALSE, stars = FALSE,
    xlas = 2, show.legend = FALSE,
    main = "Correlations of main variables"
  )
```

# Models

## Simple correlation

A new data frame for e.g. regression models

```{r}
# within and between component of predictors
# !! for now replace missing telemetry with subjective estimate !!
d_model <- d %>%
  ### !! Remove this when data is available !!
  mutate(Hours = coalesce(Hours, hours_est)) %>%
  select(Game, pid, Wave, Hours, SPANE, CSAS, Needs, Enjoyment) %>%
  arrange(Game, pid, Wave) %>%
  # Grand mean centered hours
  mutate(Hours_g = Hours - mean(Hours, na.rm = T)) %>%
  # Subject-mean Hours_g, and deviations therein
  group_by(Game, pid) %>%
  mutate(
    Hours_b = mean(Hours_g, na.rm = T),
    Hours_w = Hours_g - Hours_b
  ) %>%
  ungroup()
```

Regression coefficients (standardized and raw) of well-being predicted from game play need satisfaction, and intrinsic motivation (enjoyment).

```{r}
d_model %>%
  rename(Affect = SPANE, `Life satisfaction` = CSAS) %>%
  mutate(Hours = Hours/10) %>% 
  pivot_longer(
    c(Affect, `Life satisfaction`), 
    names_to = "Outcome", values_to = "Outcome_value"
  ) %>%
  pivot_longer(
    c(Needs, Enjoyment, Hours), 
    names_to = "Predictor", values_to = "Predictor_value"
  ) %>% 
  group_by(Game, Outcome, Predictor, Wave) %>%
  summarise(
    std = list(tidy(lm(scale(Outcome_value) ~ scale(Predictor_value), data = cur_data()), conf.int = TRUE)),
    raw = list(tidy(lm(Outcome_value ~ Predictor_value, data = cur_data()), conf.int = TRUE)),
  ) %>%
  pivot_longer(std:raw, names_to = "Model") %>%
  unnest(value) %>%
  filter(term != "(Intercept)") %>%
  mutate(Panel = str_glue("{Outcome} ({Model})")) %>%
  mutate(
    Panel = factor(
      Panel,
      levels = c(
        "Affect (raw)", "Life satisfaction (raw)",
        "Affect (std)", "Life satisfaction (std)"
      )
    )
  ) %>%
  ggplot(aes(estimate, Game, col = Wave)) +
  geom_vline(xintercept = 0, lty = 2, size = .25) +
  scale_x_continuous(
    "Bivariate regression coefficient (95%CI)",
    breaks = pretty_breaks()
  ) +
  geom_pointrangeh(
    aes(xmin = conf.low, xmax = conf.high),
    size = .3,
    position = position_dodge2v(.4)
  ) +
  facet_grid(Panel~Predictor, scales = "free_x") +
  theme(
    axis.title.x = element_markdown(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )
```

# RICLPM

Wrangle data to a format where lavaan model is easier to map to variable pairs: Wide format with different rows for outcomes (well-being) and predictors (hours, needs, motivations).

```{r}
d_riclpm_long <- d %>%
  ### !! Remove this when data is available !!
  filter(!(Game %in% c("Forza Horizon 4", "Gran Turismo Sport"))) %>%
  mutate(Hours = coalesce(Hours, hours_est)) %>%
  # Make coefficients scales more reasonable by dividing hours by ten
  mutate(Hours = Hours / 10) %>%
  select(Game, pid, wid, Hours, Needs, Enjoyment, SPANE, CSAS) %>%
  # Long format on well-being scores (outcomes)
  pivot_longer(
    c(SPANE, CSAS), names_to = "y_var", values_to = "y"
  ) %>%
  # Long format on other variables (predictors)
  pivot_longer(
    c(Hours, Needs, Enjoyment), 
    names_to = "x_var", values_to = "x"
  )
d_riclpm_wide <- d_riclpm_long %>% 
  pivot_wider(names_from = wid, values_from = c(x, y), names_sep = "")
```

## Some kind of data figure

```{r}
Order <- tibble(
  y_var = c("SPANE", "CSAS", "SPANE", "CSAS"),
  wid = c(2, 2, 3, 3),
  Panel = c(
    "Affect[plain('[Wave 2]')]",
    "Life~satisfaction[plain('[Wave 2]')]",
    "Affect[plain('[Wave 3]')]",
    "Life~satisfaction[plain('[Wave 3]')]"
  ),
  Panel_label = fct_inorder(Panel)
)

d_riclpm_plots <- d_riclpm_long %>% 
  arrange(Game, pid, x_var, wid) %>%
  group_by(Game, pid, x_var, y_var) %>%
  mutate(lag_x = lag(x)) %>%
  left_join(Order) %>% 
  ungroup() %>% 
  filter(wid > 1)

d_riclpm_plots %>% 
  filter(x_var == "Hours", lag_x <= 5) %>% 
  ggplot(aes(lag_x, y, col = Game)) + 
  scale_x_continuous(
    "Hours played at previous wave",
    breaks = pretty_breaks(), 
    labels = function(x) x*10
  ) +
  scale_y_continuous(
    "Well-being at current wave",
    breaks = pretty_breaks()
  ) +
  scale_color_brewer(palette = "Set1", aesthetics = c("color", "fill")) +
  geom_smooth(
    method = "lm", size = .4,
    alpha = .2, show.legend = FALSE
  ) +
  geom_point(size = .2, alpha = .5) +
  guides(
    color = guide_legend(
      override.aes = list(size = 2, shape = 16, alpha = 1),
      nrow = 2, byrow = TRUE
    ),
    fill = guide_legend(nrow = 2, byrow = TRUE)
  ) +
  theme(
    aspect.ratio = 1,
    legend.position = "bottom", 
    legend.justification = "left", 
    legend.margin = margin(l = -12),
    legend.title = element_blank(), 
    legend.text = element_text(margin = margin(l = -8), size = 8)
  ) +
  facet_wrap("Panel_label", scales = "free_y", labeller = label_parsed)
ggsave(here("Output/Figures/Figure-2.png"), width = 5, height = 4)

# How many x values are over 50?
last_plot()$data %>% 
  mutate(too_great = lag_x >= 5) %>%
  tabyl(too_great) %>%
  adorn_pct_formatting()
```

### Kristoffer's alternative plot
I'd also facet this one, and use LOESS.

```{r}
d_riclpm_plots %>% 
  filter(x_var == "Hours", lag_x <= 5) %>% 
  ggplot(aes(lag_x, y, col = Game)) +
  scale_x_continuous(
    "Hours played at previous wave",
    breaks = pretty_breaks()
  ) +
  scale_y_continuous(
    "Well-being at current wave",
    breaks = pretty_breaks()
  ) +
  scale_color_brewer(palette = "Set1", aesthetics = c("color", "fill")) +
  geom_point(size = .2, alpha = .2, shape = 1) +
  geom_smooth(
    method = "loess", size = .9,
    color = "black",
    alpha = .2, show.legend = FALSE
  ) +
  guides(
    color = guide_legend(
      override.aes = list(size = 2, shape = 16, alpha = 1)
    )
  ) +
  facet_grid(Panel_label ~ Game, scales = "free_y") +
  #scale_x_continuous(trans = "log1p", breaks = c(0, 1,  5, 20, 60)) +
  theme(aspect.ratio = 1)
ggsave(here("Output/Figures/Figure-2-1-raw.png"), width = 6, height = 5)
```


## Fit one model to all data

First fit RICLPM to all data. Separately to the two well-being outcomes, and each predictor (hours, subjective scales). Constrain (cross)lagged parameters

Syntax based on <https://jeroendmulder.github.io/RI-CLPM/lavaan.html>

```{r}
riclpm_constrained <- "
  # Create between components (random intercepts)
  RIx =~ 1*x1 + 1*x2 + 1*x3
  RIy =~ 1*y1 + 1*y2 + 1*y3

  # Create within-person centered variables
  wx1 =~ 1*x1
  wx2 =~ 1*x2
  wx3 =~ 1*x3
  wy1 =~ 1*y1
  wy2 =~ 1*y2
  wy3 =~ 1*y3

  # Estimate the lagged effects between the within-person centered variables (constrained).
  wx2 ~ bx*wx1 + gx*wy1
  wy2 ~ gy*wx1 + by*wy1
  wx3 ~ bx*wx2 + gx*wy2
  wy3 ~ gy*wx2 + bx*wy2

  # Estimate the covariance between the within-person centered
  # variables at the first wave.
  wx1 ~~ wy1 # Covariance

  # Estimate the covariances between the residuals of the
  # within-person centered variables (the innovations).
  wx2 ~~ wy2
  wx3 ~~ wy3

  # Estimate the variance and covariance of the random intercepts.
  RIx ~~ RIx
  RIy ~~ RIy
  RIx ~~ RIy

  # Estimate the (residual) variance of the within-person centered variables.
  wx1 ~~ wx1 # Variances
  wy1 ~~ wy1
  wx2 ~~ wx2 # Residual variances
  wy2 ~~ wy2
  wx3 ~~ wx3
  wy3 ~~ wy3
"
```

```{r}
cluster_copy(cluster, "riclpm_constrained")
fit_riclpm_all <- d_riclpm_wide %>%
  group_by(y_var, x_var) %>%
  partition(cluster) %>%
  summarise(
    fit = lavaan(
      riclpm_constrained,
      data = cur_data(),
      missing = "ml",
      meanstructure = TRUE,
      int.ov.free = TRUE
    ) %>% list()
  ) %>% collect()

get_lavaan_pars <- function(x) {
  bind_rows(
    parameterestimates(x) %>%
      mutate(Type = "Unstandardized"),
    standardizedsolution(x) %>%
      rename(est = est.std) %>%
      mutate(Type = "Standardized")
  ) %>%
    as_tibble() %>%
    unite("Parameter", c(lhs, op, rhs), sep = " ", remove = FALSE)
}

pars_riclpm_avg <- fit_riclpm_all %>%
  mutate(pars = map(fit, get_lavaan_pars)) %>%
  select(-fit)
```

## Separate models per game

Fit the above model separately to each game.

```{r}
fit_riclpm_sep <- d_riclpm_wide %>%
  group_by(y_var, x_var, Game) %>%
  partition(cluster) %>%
  summarise(
    fit = lavaan(
      riclpm_constrained,
      data = cur_data(),
      missing = "ml",
      meanstructure = TRUE,
      int.ov.free = TRUE
    ) %>% list()
  ) %>% collect()
pars_riclpm_sep <- fit_riclpm_sep %>%
  mutate(pars = map(fit, get_lavaan_pars)) %>%
  select(-fit)
```

## Multi-group fit with parameter constraints

Fit the model to all the data but allow unique (cross)lagged parameters for each game. This may help if some data sets are too small to fit the model completely independently.

```{r}
riclpm_constrained_multigroup <- "
  # Create between components (random intercepts)
  RIx =~ 1*x1 + 1*x2 + 1*x3
  RIy =~ 1*y1 + 1*y2 + 1*y3

  # Create within-person centered variables
  wx1 =~ 1*x1
  wx2 =~ 1*x2
  wx3 =~ 1*x3
  wy1 =~ 1*y1
  wy2 =~ 1*y2
  wy3 =~ 1*y3

  # Estimate the lagged effects between the within-person centered variables (constrained)
  # such that each group gets their own coefs
  wx2 ~ c(bx1, bx2, bx3, bx4, bx5)*wx1 + c(gx1, gx2, gx3, gx4, gx5)*wy1
  wy2 ~ c(gy1, gy2, gy3, gy4, gy5)*wx1 + c(by1, by2, by3, by4, by5)*wy1
  wx3 ~ c(bx1, bx2, bx3, bx4, bx5)*wx2 + c(gx1, gx2, gx3, gx4, gx5)*wy2
  wy3 ~ c(gy1, gy2, gy3, gy4, gy5)*wx2 + c(by1, by2, by3, by4, by5)*wy2

  # Estimate the covariance between the within-person centered
  # variables at the first wave.
  wx1 ~~ wy1 # Covariance

  # Estimate the covariances between the residuals of the
  # within-person centered variables (the innovations).
  wx2 ~~ wy2
  wx3 ~~ wy3

  # Estimate the variance and covariance of the random intercepts.
  RIx ~~ RIx
  RIy ~~ RIy
  RIx ~~ RIy

  # Estimate the (residual) variance of the within-person centered variables.
  wx1 ~~ wx1 # Variances
  wy1 ~~ wy1
  wx2 ~~ wx2 # Residual variances
  wy2 ~~ wy2
  wx3 ~~ wx3
  wy3 ~~ wy3
"
```

```{r}
cluster_copy(cluster, "riclpm_constrained_multigroup")
fit_riclpm_mg <- d_riclpm_wide %>%
  group_by(y_var, x_var) %>%
  partition(cluster) %>%
  summarise(
    fit = lavaan(
      riclpm_constrained_multigroup,
      data = cur_data(),
      missing = "ml",
      group = "Game",
      meanstructure = TRUE,
      int.ov.free = TRUE
    ) %>% list()
  ) %>% collect()

pars_riclpm_mg <- fit_riclpm_mg %>%
  mutate(pars = map(fit, get_lavaan_pars)) %>%
  mutate(
    pars = map2(
      pars, fit,
      ~ left_join(
        .x, 
        tibble(
          group = 1:length(unique(d_riclpm_wide$Game)), 
          Game = .y@Data@group.label
        )
      )
    )
  ) %>%
  select(-fit)
```

Look at estimates

```{r}
# Table of RICLPM parameters
pars_riclpm <- pars_riclpm_mg %>%
  unnest(pars) %>%
  group_by(y_var, x_var, Game) %>%
  nest() %>%
  rename(pars = data) %>%
  mutate(Model = "Multigroup") %>%
  bind_rows(pars_riclpm_sep %>% mutate(Model = "Independent")) %>%
  bind_rows(pars_riclpm_avg %>% mutate(Model = "Average", Game = "Average")) %>%
  ungroup() %>%
  unnest(pars) %>%
  # Take regression parameters at first interval, and 
  # covariance parameters of interest
  filter(
    (str_detect(Parameter, " ~ ") & !str_detect(Parameter, "3")) |
    Parameter %in% c("RIx ~~ RIy", "wx1 ~~ wy1", "wx2 ~~ wy2", "wx3 ~~ wy3")
  ) %>%
  mutate(Game = fct_relevel(Game, "Average"))

# Plot of regression parameters (autocorrelations and crosslags; raw)
pars_riclpm %>%
  rename(Predictor = x_var, Outcome = y_var) %>% 
  filter(Type == "Unstandardized", str_detect(Parameter, " ~ ")) %>% 
  ggplot(
    aes(
      est, Game, 
      col = Model, xmin = ci.lower, xmax = ci.upper, shape = Outcome
    )
  ) +
  scale_x_continuous(
    "Estimate",
    breaks = pretty_breaks()
  ) +
  geom_vline(xintercept = 0, size = .2, lty = 2) +
  geom_pointrangeh(position = position_dodge2v(.5), size = .4) +
  facet_grid(Parameter ~ Predictor, scales = "free_x", labeller = label_both)

# Plots of covariance parameters (raw)
last_plot() %+% 
  filter(
    pars_riclpm %>% rename(Predictor = x_var, Outcome = y_var), 
    Type == "Unstandardized", 
    str_detect(Parameter, " ~~ ")
  )
```

We need to decide whether to use multigroup estimates or independent model estimates. Potentially former and maybe give more game-specific parameters in the model. For now we have gone with independent model estimates.

# Meta-analyses

Number of observations/participants per model

```{r}
fit_riclpm_sep %>%
  mutate(N = map_dbl(fit, nobs) %>% comma) %>% 
  select(-fit) %>% 
  pivot_wider(
    names_from = x_var, 
    values_from = N, 
    names_glue = "{x_var} {.value}"
  ) %>% 
  rename(Outcome = y_var) %>% 
  kable(caption = "Sample sizes per RICLPM")
```

Then conduct all meta-analyses (for each y_var-x_var pair, parameter of interest, and type of parameter (standardized, unstandardized)) based on the independent fit RICLPMs

```{r results='hide'}
# Meta-analyze the models fitted independently to games
# Select these parameters only
d_ma <- pars_riclpm %>%
  filter(Model == "Independent", str_detect(Parameter, " ~ "))

# Compile meta-analytic brms/Stan model
bf_ma <- bf(est | se(se) ~ 0 + Intercept + (0 + Intercept | Game))
fit_ma_empty <- brm(
  bf_ma,
  data = d_ma,
  prior = prior(student_t(7, 0, 0.25), class = "sd", group = "Game") +
    prior(normal(0, 0.5), class = "b"),
  chains = 0,
  control = list(adapt_delta = .9999, max_treedepth = 15),
  file = here("Output/brms/brm-ma-empty")
)

# Fit meta-analysis separately to each x-y pair X parameter X type 
# by updating the compiled model (48 meta-analyses)
cluster_library(cluster, c("brms", "here", "stringr"))
cluster_copy(cluster, "fit_ma_empty")
fit_ma <- d_ma %>%
  group_by(x_var, y_var, Parameter, lhs, rhs, Type) %>%
  mutate(i = cur_group_id()) %>%
  partition(cluster) %>%
  summarise(
    fit = list(
      update(
        fit_ma_empty,
        newdata = cur_data(),
        control = list(adapt_delta = .9999, max_treedepth = 15),
        iter = 15000, warmup = 5000, 
        refresh = 0,
        file = here(str_glue("Output/brms/brm-ma-{unique(i)}"))
      )
    )
  ) %>% 
  collect()

# Function to get varying and average effects' posteriors from brmsfit
get_ma_post <- function(x) {
  coef(x, summary = FALSE) %>%
    .[["Game"]] %>%
    .[, , 1] %>%
    as.data.frame() %>%
    as_tibble() %>%
    cbind(fixef(x, summary = FALSE))
}
```

Also run meta-analysis for multigroup models

```{r results='hide'}
d_ma_multi <- pars_riclpm %>%
  filter(Model == "Multigroup", str_detect(Parameter, " ~ "))

fit_ma_multi <- d_ma_multi %>%
  group_by(x_var, y_var, Parameter, lhs, rhs, Type) %>%
  mutate(i = cur_group_id()) %>%
  partition(cluster) %>%
  summarise(
    fit = list(
      update(
        fit_ma_empty,
        newdata = cur_data(),
        control = list(adapt_delta = .9999, max_treedepth = 15),
        iter = 15000, warmup = 5000, 
        refresh = 0,
        file = here(str_glue("Output/brms/brm-ma-multi-{unique(i)}"))
      )
    )
  ) %>% 
  collect()
```

## Hours <-> WB

Draw a forest plot of meta-analyses with hours

```{r}
#' Summarize meta-analyses
#' @param object a grouped df with all the brmsfits; e.g., fit_ma
#' 
#' @return a list with 
#'  - `summary`:
#'  - `draws`: the posterior draws
summarize_ma <- function(object) {
  Order <- distinct(object, x_var, y_var, Parameter, lhs, rhs) %>% 
  ungroup() %>% 
  # Meta-analyses only for regression parameters
  filter(str_detect(Parameter, " ~ ")) %>% 
  mutate(
    x_lab = case_when(
      x_var == "Hours" ~ "Play",
      x_var == "Enjoyment" ~ "Intrinsic~motivation",
      x_var == "Needs" ~ "Need~satisfaction"
    ),
    y_lab = case_when(
      y_var == "SPANE" ~ "Affect",
      y_var == "CSAS" ~ "Life~satisfaction"
    ),
    Panel_label = case_when(
      Parameter == "wx2 ~ wx1" ~ 
        str_glue('{x_lab}[plain("[t-1]")]%->%{x_lab}[plain("[t]")]'),
      Parameter == "wy2 ~ wy1" ~ 
        str_glue('{y_lab}[plain("[t-1]")]%->%{y_lab}[plain("[t]")]'),
      Parameter == "wy2 ~ wx1" ~ 
        str_glue('{x_lab}[plain("[t-1]")]%->%{y_lab}[plain("[t]")]'),
      Parameter == "wx2 ~ wy1" ~ 
        str_glue('{y_lab}[plain("[t-1]")]%->%{x_lab}[plain("[t]")]')
    )
  ) %>% 
  mutate(
    Parameter_order = factor(
      Parameter, 
      levels = c("wy2 ~ wx1", "wx2 ~ wy1", "wy2 ~ wy1", "wx2 ~ wx1")
      )
    ) %>% 
  arrange(Parameter_order, desc(y_var)) %>% 
  mutate(Panel_label = fct_inorder(Panel_label))
  # Did ordering work?
  # Order %>% 
  #   filter(x_var == "Enjoyment", Parameter %in% c("wy2 ~ wx1", "wx2 ~ wy1")) %>% 
  #   mutate(n = as.numeric(Panel_label))

  # Table of ROPEs
  # Smallest subjective change as a percentage from Anvari&Lakens
  sscp <- .2 / 5
  rope_limits <- distinct(object, y_var, Parameter, Type) %>%
    mutate(
      rope_limit = case_when(
        Type == "Standardized" ~ .1,
        Type == "Unstandardized" & Parameter == "wx2 ~ wy1" ~ .1,
        y_var == "CSAS" ~ (sscp * 11) / 3,
        y_var == "SPANE" ~ (sscp * 13) / 3
      )
    )

  # Data for plotting meta-analyses' posterior distributions
  p_data <- object %>%
    mutate(out = map(fit, get_ma_post)) %>%
    select(-fit) %>%
    unnest(out) %>%
    rename(Average = Intercept) %>%
    pivot_longer(`AC:NH`:Average, names_to = "Game") %>%
    mutate(Game = fct_relevel(Game, "Average")) %>%
    ungroup() %>%
    left_join(Order) %>% 
    left_join(rope_limits)

  # Summaries of posterior distributions
  fit_ma_sum <- p_data %>%
    left_join(rope_limits) %>%
    group_by(y_var, x_var, Parameter, Type, Game, Panel_label, rope_limit) %>%
    summarise(
      describe_posterior(
        value,
        rope_range = c(-unique(rope_limit), unique(rope_limit)),
        test = c("ps", "rope"), rope_ci = 1,
        centrality = "mean"
      ) %>% select(-Parameter)
    ) %>%
    ungroup() %>%
    mutate(
      across(
        c(Mean, CI_low, CI_high),
        .fns = list(r = ~ format(round(., 2), nsmall = 2))
      )
    ) %>%
    mutate(Res = str_glue("{Mean_r} [{CI_low_r}, {CI_high_r}]")) %>%
    # Probability outside ROPE in other direction
    mutate(p_other = 1 - (ps + ROPE_Percentage)) %>%
    # Ordered labels
    left_join(Order) %>%
    mutate(Game = fct_relevel(Game, "Average"))

  list(
    summary = fit_ma_sum,
    draws = p_data
   )
}

#' Function to draw forest plots
#' @param object object created using `summarize_ma`
#' @param type
#' @param x_var
#' @param parameters
#' @param lavaan
#' 
#' @return a ggplot2 object
forest_plot <- function(
  object,
  type = "Unstandardized", 
  x_var = "Hours", 
  parameters = c("wy2 ~ wx1", "wx2 ~ wy1"),
  lavaan = FALSE
  ) {
  out <- object$summary %>%
    filter(
      Type == {{type}}, 
      x_var == {{x_var}}, 
      Parameter %in% {{parameters}}
    ) %>%
    # We can use the xintercept mapping to control alpha below
    ggplot(aes(Mean, Game, xintercept = rope_limit)) +
    coord_cartesian(xlim = c(-.4, .55)) +
    scale_x_continuous(
      "Estimated cross-lagged effect",
      breaks = c(-.3, -.2, -.1, 0, .1, .2, .3, .4),
      expand = expansion(.01)
    ) +
    scale_y_discrete(
      expand = expansion(c(0.15, 0.25)),
      labels = function(x) ifelse(x == "Average", "**Average**", x)
    ) +
    scale_alpha_manual(values = c(.33, 1)) +
    scale_fill_brewer(
      palette = "Set1", direction = 1, aesthetics = c("fill", "color")
    ) +
    # Vertical lines for ROPE and 0
    geom_vline(xintercept = 0, size = .1, col = "grey60") +
    geom_vline(
      aes(xintercept = rope_limit),
      size = .1, lty = 2, col = "grey60"
    ) +
    geom_vline(
      aes(xintercept = -rope_limit),
      size = .1, lty = 2, col = "grey60"
    ) +
    # Posterior densities
    stat_halfeye(
      data = object$draws %>% 
        filter(
          Type == {{type}}, 
          x_var == {{x_var}}, 
          Parameter %in% {{parameters}}
        ),
      aes(
        value,
        fill = stat(x > 0),
        alpha = after_stat(abs(x) > xintercept)
      ),
      height = .5, adjust = 1.5, point_interval = NULL,
      show.legend = FALSE, normalize = "panels"
    ) +
    # Summary geoms and texts
    geom_pointrangeh(
      aes(x = Mean, xmin = CI_low, xmax = CI_high),
      size = .33, fatten = 1.5
    ) +
    # CIs in right margin
    geom_text(
      vjust = -0.5, size = 3, hjust = 1,
      aes(x = .55, label = Res),
      family = Font
    ) +
    # Posterior probabilities for average
    geom_text(
      data = object$summary %>%
        filter(Game == "Average") %>%
        filter(
          Type == {{type}}, 
          x_var == {{x_var}}, 
          Parameter %in% {{parameters}}
        ),
      vjust = 1.4, size = 3,
      aes(
        x = sign(Mean) * rope_limit,
        hjust = ifelse(sign(Mean) == 1, 0, 1),
        label = str_glue("{percent(ps, .1)}"),
        col = as.logical(sign(Mean) == 1)
      ),
      family = Font,
      show.legend = FALSE
    ) +
    geom_text(
      data = object$summary %>%
        filter(Game == "Average") %>%
        filter(
          Type == {{type}}, 
          x_var == {{x_var}}, 
          Parameter %in% {{parameters}}
        ),
      vjust = 1.4, size = 3,
      aes(
        x = 0,
        hjust = 0.5,
        label = str_glue("{percent(ROPE_Percentage, .1)}")
      ),
      col = "gray50",
      family = Font,
      show.legend = FALSE
    ) +
    geom_text(
      data = object$summary %>%
        filter(Game == "Average") %>%
        filter(
          Type == {{type}}, 
          x_var == {{x_var}}, 
          Parameter %in% {{parameters}}
        ),
      vjust = 1.4, size = 3,
      aes(
        x = -sign(Mean) * rope_limit,
        hjust = ifelse(sign(Mean) == 1, 1, 0),
        label = str_glue("{percent(p_other, .1)}"),
        col = as.logical(-sign(Mean) == 1)
      ),
      family = Font,
      show.legend = FALSE
    ) +
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_markdown(),
      # panel.grid.major.y = element_blank()
    ) +
    facet_wrap("Panel_label", scales = "free_x", labeller = label_parsed)
  
  # Also display lavaan game-specific estimates?
  if (lavaan) {
    out +
      geom_pointrangeh(
        data = d_ma %>%
          left_join(Order) %>% 
          filter(
            Type == {{type}}, 
            x_var == {{x_var}}, 
            Parameter %in% {{parameters}}
          ) %>% 
          mutate(rope_limit=.1),
        col = "gray40", fatten = 1.25, size = .33,
        aes(x = est, xmin = ci.lower, xmax = ci.upper),
        position = position_nudge(y = -.075)
      )
  } else out
}
```

```{r}
fit_ma_sum <- summarize_ma(fit_ma)
forest_plot(
  fit_ma_sum,
  "Unstandardized", 
  "Hours",
  parameters = c("wy2 ~ wx1", "wx2 ~ wy1"), 
  lavaan = FALSE
)
ggsave(here("Output/Figures/Figure-3-Unstandardized.png"), width = 8, height = 5)
# forest_plot("Standardized")
# ggsave(here("Output/Figures/Figure-3-Standardized.png"), width = 8, height = 5)
```

Multigroup model

```{r}
fit_ma_multi_sum <- summarize_ma(fit_ma_multi)
forest_plot(
  fit_ma_multi_sum,
  "Unstandardized", 
  "Hours",
  parameters = c("wy2 ~ wx1", "wx2 ~ wy1"), 
  lavaan = FALSE
)
```

```{r}
# Also see in comparison to individual model estimates
forest_plot(
  fit_ma_sum,
  "Unstandardized", 
  "Hours",
  parameters = c("wy2 ~ wx1", "wx2 ~ wy1"), 
  lavaan = TRUE
)
```

Table?

```{r}
fit_ma_sum$summary %>%
  select(y_var, x_var, Game, Parameter, Type, Res) %>% 
  DT::datatable(filter = "top")
```


## Experiences <-> WB

These meta-analyses were conducted above. Now we just need to filter for the correct parameters for plots. They are also shown in the table above. Need to double check that everything has worked so these meta analyses are still a bit of WIP.

```{r}
forest_plot(
  fit_ma_sum,
  "Unstandardized", 
  "Enjoyment",
  parameters = c("wy2 ~ wx1"), 
  lavaan = FALSE
) + theme(axis.title.x = element_blank()) -
forest_plot(
  fit_ma_sum,
  "Unstandardized", 
  "Needs",
  parameters = c("wy2 ~ wx1"), 
  lavaan = FALSE
) +
  plot_layout(nrow = 2)
ggsave(
  here("Output/Figures/Figure-ma-subjective-Unstandardized.png"), 
  width = 8, 
  height = 5
  )
```

