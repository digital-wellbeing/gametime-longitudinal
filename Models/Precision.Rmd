---
title: 'Design analysis'
author: "Matti"
date: "This week"
output: html_document
---

```{r packages, results = 'hide'}
library(knitr)
library(here)
library(lavaan)
library(broom.mixed)
library(broom)
library(scales)
library(parallel)
library(tidyverse)
```

```{r setup, include=FALSE}
opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores(logical = FALSE))
```


# Preface

Design analysis of RICLPM and subsequent meta-analytic model of future gaming and well-being data.

The proposed model to fit to each game's data is the RICLPM with constraints on lagged and cross lagged effects to equate them across the two lags.

```{r}
# Based on: https://jeroendmulder.github.io/RI-CLPM/lavaan.html
riclpm_constrained <- '
  # Create between components (random intercepts)
  RIx =~ 1*x1 + 1*x2 + 1*x3
  RIy =~ 1*y1 + 1*y2 + 1*y3

  # Create within-person centered variables
  wx1 =~ 1*x1
  wx2 =~ 1*x2
  wx3 =~ 1*x3
  wy1 =~ 1*y1
  wy2 =~ 1*y2
  wy3 =~ 1*y3

  # Estimate the lagged effects between the within-person centered variables (constrained).
  wx2 ~ beta_x*wx1 + gamma_x*wy1 
  wy2 ~ gamma_y*wx1 + beta_y*wy1
  wx3 ~ beta_x*wx2 + gamma_x*wy2
  wy3 ~ gamma_y*wx2 + beta_x*wy2

  # Estimate the covariance between the within-person centered
  # variables at the first wave.
  wx1 ~~ wy1 # Covariance

  # Estimate the covariances between the residuals of the
  # within-person centered variables (the innovations).
  wx2 ~~ wy2
  wx3 ~~ wy3

  # Estimate the variance and covariance of the random intercepts.
  RIx ~~ RIx
  RIy ~~ RIy
  RIx ~~ RIy

  # Estimate the (residual) variance of the within-person centered variables.
  wx1 ~~ wx1 # Variances
  wy1 ~~ wy1
  wx2 ~~ wx2 # Residual variances
  wy2 ~~ wy2
  wx3 ~~ wx3
  wy3 ~~ wy3
'
```

# Precision

This simulation studies model convergence and precision in parameter estimates under different assumptions about 

- Wave 1 sample size (500-2000)
- Probability of responding at waves 2 and 3 (40% and 80%)
- Cross-lagged path coefficient from X to Y (0.1 to 0.3)

All standard deviations were set to 1, and correlations to 0.25. Missing data was modelled with FIML.

```{r, cache = TRUE}
# DGP function for RICLPM
source(here("Models/RI-CLPM/simulate-RICLPM-data.R"))

# Grid of parameters
sim <- crossing(
  # Repetitions for simulation
  i = 1:100,
  # Response rate for waves 2 and 3
  p_resp = c(.4, .8),
  n = seq(500, 2000, by = 500),
  # beta = autoregressive params
  beta_2x = 0.6,
  beta_2y = 0.6,
  beta_3x = 0.6,
  beta_3y = 0.6,
  # gamma = cross-lagged effects (can vary but remember nesting here because equality constraint)
  nesting(
    gamma_2x = 0.05,
    gamma_2y = 0.1,
    gamma_3x = 0.05,
    gamma_3y = 0.1,
  ),
  x_mean = 0,
  y_mean = 0,
  ## covariances
  sd_wx1 = 1,
  sd_wy1 = 1,
  cor_wx1_wy1 = 0.25,
  sd_wx2 = 1,
  sd_wy2 = 1,
  cor_wx2_wy2 = 0.25,
  sd_wx3 = 1,
  sd_wy3 = 1,
  cor_wx3_wy3 = 0.25,
  sd_x_RE = 1,
  sd_y_RE = 1,
  cor_xy_intercepts = 0.25
)

# Generate data
sim$data <- sim %>% 
  pmap(sim_RICLPM_data)

# Fit model in parallel with function allowing for errors
lavaan_safe <- possibly(lavaan, otherwise = NA)
sim$fit <- mclapply(
  sim$data, 
  function(x) lavaan_safe(
    riclpm_constrained, 
    data = x,  
    meanstructure = TRUE, 
    int.ov.free = TRUE,
    missing = "ml"
  )
)

# Detect errors (failures to fit model--convergence)
sim <- sim %>% 
  mutate(converged = map_lgl(fit, ~.x@Fit@converged))

# Get coefficients
sim$tab <- mclapply(
  sim$fit,
  function(x) tidy(x, conf.int = TRUE) %>% filter(op == "~")
)
```

First check how often the model converged. Under these assumptions model convergence looks good.

```{r}
sim %>% 
  group_by(p_resp, n) %>% 
  summarise(Converged = percent(sum(converged)/n(), .1))
```

Given that we set all standard deviations to 1, we can very roughly think of the lagged effects' magnitudes as similar to standardized effects, but we could also consider different proportions etc.

Here we compute the average width of the 95%CIs at each level of the parameters chosen. These should be the same for the different outcomes, unless different parameters are chosen.

```{r fig.height = 3}
widths <- sim %>% 
  unnest(tab) %>% 
  select(i, n, p_resp, gamma_2y, label, term:conf.high) %>% 
  mutate(p_resp = factor(p_resp, labels = c("40%", "80%"))) %>% 
  # Take only first lag because values are duplicated due to constraints
  filter(term %in% c("wx2 ~ wy1", "wy2 ~ wx1")) %>% 
  mutate(width = conf.high - conf.low)
widths %>%
  group_by(label, n, p_resp) %>%
  summarise(width = mean(width, na.rm = TRUE)) %>%
  separate(label, c("Parameter", "Outcome")) %>% 
  ggplot(aes(n, width, col = p_resp)) +
  scale_color_brewer("Response rate", palette = "Set1") +
  scale_y_continuous(
    "Mean 95%CI width", breaks = pretty_breaks()
  ) +
  scale_x_continuous(
    "Wave 1 sample size",
    breaks = pretty_breaks()
  ) +
  geom_line() +
  facet_grid(~Outcome, labeller = label_both)
```

# Meta-analysis

tbd

# Conclusions

- Models seem to converge OK with just 500 wave 1 respondents and 40% response rates at waves 2 and 3.
- Even at 2000 wave 1 participants and 80% response rates at waves 2 and 3, the cross-lagged parameters' precision is not very high, although it might approach reasonable levels (95% widths ~0.15).
- With above, and a meta-analytic model summarising over the different games, could reach sufficient precision, tbd.
