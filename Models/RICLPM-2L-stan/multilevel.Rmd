---
title: "Multilevel RICLPM in Stan vs lavaan multigroup + meta-analysis"
author: "Kristoffer Magnusson"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(blavaan)
library(lavaan)
library(brms)
library(tidyverse)
library(multidplyr)
library(here)
library(knitr)
```

In this document I try to fit a multilevel RICLPM using custom stan code (based on a blavaan model), I then compare it to the multigroup lavaan + random effects meta-analysis approach. At the end there's also a small simulation study of frequentist properties of the lavaan multigroup + MA approach.

## Simulate data
Let's simulate a multilevel version of the RICLPM. We'll do 10 games and 50 participants per game. I'll add random effects to the within regression coefs only. All other parameters are shared by all games.  

```{r}
source(here("Models/RI-CLPM/simulate-RICLPM-data.R"))
params <- list(
    n = 50, # n per game
    n2 = 10, # n games
    # beta = autoregressive params
    beta_2x = 0.66,
    beta_2y = 0.33,
    beta_3x = 0.66,
    beta_3y = 0.33,
    # gamma = cross-lagged effects
    gamma_2x = 0.22,
    gamma_2y = 0.55,
    gamma_3x = 0.22,
    gamma_3y = 0.55,
    # multilevel
    gamma_x_sd = 0.5,
    gamma_y_sd = 0.5,
    beta_x_sd = 0.5,
    beta_y_sd = 0.5,
    x_mean = 2,
    y_mean = 4,
    ## covariances
    sd_wx1 = 1,
    sd_wy1 = 1,
    cor_wx1_wy1 = 0.5,
    sd_wx2 = 1.7,
    sd_wy2 = 1.33,
    cor_wx2_wy2 = 0.6,
    sd_wx3 = 1.33,
    sd_wy3 = 1.44,
    cor_wx3_wy3 = 0.44,
    sd_x_RE = 1.2,
    sd_y_RE = 1.44,
    cor_xy_intercepts = 0.33
)
set.seed(4545)
d <- do.call(sim_RICLPM_data, params)
kable(head(d), digits = 2)
kable(colMeans(d), digits = 2)

```

I also center the variables in a vain hope of speeding up the sampling.
```{r}
d2 <- d %>%
  mutate(
    x1 = x1 - mean(x1),
    x2 = x2 - mean(x2),
    x3 = x3 - mean(x3),
    y1 = y1 - mean(y1),
    y2 = y2 - mean(y2),
    y3 = y3 - mean(y3)
)
```

## Model
We'll use the constrained lavaan model as a template

```{r}
riclpm <- '
  # Create between components (random intercepts)
  RIx =~ 1*x1 + 1*x2 + 1*x3
  RIy =~ 1*y1 + 1*y2 + 1*y3

  # Create within-person centered variables
  wx1 =~ 1*x1
  wx2 =~ 1*x2
  wx3 =~ 1*x3
  wy1 =~ 1*y1
  wy2 =~ 1*y2
  wy3 =~ 1*y3

  # Estimate the lagged effects between the within-person centered variables.
  wx2 ~ a*wx1 + b*wy1 
  wy2 ~ c*wx1 + d*wy1
  wx3 ~ a*wx2 + b*wy2
  wy3 ~ c*wx2 + d*wy2

  # Estimate the covariance between the within-person centered
  # variables at the first wave.
  wx1 ~~ wy1 # Covariance

  # Estimate the covariances between the residuals of the
  # within-person centered variables (the innovations).
  wx2 ~~ wy2
  wx3 ~~ wy3

  # Estimate the variance and covariance of the random intercepts.
  RIx ~~ RIx
  RIy ~~ RIy
  RIx ~~ RIy

  # Estimate the (residual) variance of the within-person centered variables.
  wx1 ~~ wx1 # Variances
  wy1 ~~ wy1
  wx2 ~~ wx2 # Residual variances
  wy2 ~~ wy2
  wx3 ~~ wx3
  wy3 ~~ wy3
'
```

We get the data and stan code from a multigroup blavaan model.

```{r, eval = FALSE}
fit_tmp <- blavaan(
    riclpm, data = d2,
    group = "cluster",
    target = "stanclassic",
    meanstructure = TRUE, 
    int.ov.free = TRUE,
    burnin = 0,
    sample = 0,
    mcmcfile = "lavExportStanML",
    bcontrol = list(cores = 1, control = list(adapt_delta = 0.8))
)
```

I've manually modified the stan code into a multilevel model instead.

```{r, eval = FALSE}
library(cmdstanr)
mod <- cmdstan_model(
    stan_file = here("Models/RICLPM-2L-stan/lavExportStanML/semML.stan")
    )
# load the standata exported from blavaan    
load(here("Models/RICLPM-2L-stan/lavExportStanML/semstan.rda"))
standata <- stantrans$data
# add custom data for ML
n2 <- length(unique(d$cluster))
standata$M_1 <- 4 # n game-level REs
standata$N_1 <- 50
standata$N_2 <- n2
standata$J_1 <- d$cluster

# Fit model
fit <- mod$sample(
  data = standata,
  chains = 3,
  parallel_chains = 3,
  max_treedepth = 10,
)
fit$save_object(
    file = here("Models/RICLPM-2L-stan/lavExportStanML/fit_ML.rds")
    )
```

## Results
It took approx 6500 seconds to fit on a rather slow Xeon CPU. All iter hit max three depth, but results seem fine.

```{r, include = FALSE}
fit <- readRDS(here("Models/RICLPM-2L-stan/fit_ML.rds"))
```


```{r}
coef_sum <- fit$summary(
  c(
    paste0("betafree[", 1:4, "]"),
    paste0("sd_1[", 1:4, "]"),
    paste0("psifree[", 1:8, "]")
    ), 
  mean, median, sd,
  ~quantile(.x, probs = c(0.025, 0.975)),
  "rhat", "ess_bulk", "ess_tail"
  )

kable(coef_sum, digits = 2)  
```

## Multigroup + meta-analyze approach 
Let's also fit a multigroup model in lavaan, where only the within latent regressions are free to vary. This is similar to the Stan model, and the DGP.

```{r}
riclpm_constrained_multigroup <- "
  # Create between components (random intercepts)
  RIx =~ 1*x1 + 1*x2 + 1*x3
  RIy =~ 1*y1 + 1*y2 + 1*y3

  # Create within-person centered variables
  wx1 =~ 1*x1
  wx2 =~ 1*x2
  wx3 =~ 1*x3
  wy1 =~ 1*y1
  wy2 =~ 1*y2
  wy3 =~ 1*y3

  # Estimate the lagged effects between the within-person centered variables (constrained)
  # such that each group gets their own coefs
  wx2 ~ c(bx1, bx2, bx3, bx4, bx5, bx6, bx7, bx8, bx9, bx10)*wx1 + c(gx1, gx2, gx3, gx4, gx5, gx6, gx7, gx8, gx9, gx10)*wy1
  wy2 ~ c(gy1, gy2, gy3, gy4, gy5, gy6, gy7, gy8, gy9, gy10)*wx1 + c(by1, by2, by3, by4, by5, by6, by7, by8, by9, by10)*wy1
  wx3 ~ c(bx1, bx2, bx3, bx4, bx5, bx6, bx7, bx8, bx9, bx10)*wx2 + c(gx1, gx2, gx3, gx4, gx5, gx6, gx7, gx8, gx9, gx10)*wy2
  wy3 ~ c(gy1, gy2, gy3, gy4, gy5, gy6, gy7, gy8, gy9, gy10)*wx2 + c(by1, by2, by3, by4, by5, by6, by7, by8, by9, by10)*wy2

  # Estimate the covariance between the within-person centered
  # variables at the first wave.
  wx1 ~~ wy1 # Covariance

  # Estimate the covariances between the residuals of the
  # within-person centered variables (the innovations).
  wx2 ~~ wy2
  wx3 ~~ wy3

  # Estimate the variance and covariance of the random intercepts.
  RIx ~~ RIx
  RIy ~~ RIy
  RIx ~~ RIy

  # Estimate the (residual) variance of the within-person centered variables.
  wx1 ~~ wx1 # Variances
  wy1 ~~ wy1
  wx2 ~~ wx2 # Residual variances
  wy2 ~~ wy2
  wx3 ~~ wx3
  wy3 ~~ wy3
"
```

```{r}
fit_multi = lavaan(
      riclpm_constrained_multigroup,
      data = d,
      group = "cluster",
      group.equal = c(
          "residuals", 
          "residual.covariances",
          "lv.variances", 
          "lv.covariances"),
      meanstructure = TRUE,
      int.ov.free = TRUE
    )
```

```{r}
get_lavaan_pars <- function(x) {
  bind_rows(
    parameterestimates(x) %>%
      mutate(Type = "Unstandardized")
  ) %>%
    as_tibble() %>%
    unite("Parameter", c(lhs, op, rhs), sep = " ", remove = FALSE)
}

pars_riclpm_mg <- get_lavaan_pars(fit_multi)


```

Run the coefficients through a random effects meta-analysis.

```{r results='hide'}
# Meta-analyze the models fitted independently to games
# Select these parameters only
d_ma <- pars_riclpm_mg %>%
  filter(Type == "Unstandardized", str_detect(Parameter, " ~ ")) %>%
  filter(Parameter %in% c("wx2 ~ wx1", "wx2 ~ wy1", "wy2 ~ wy1", "wy2 ~ wx1"))

# Compile meta-analytic brms/Stan model
bf_ma <- bf(est | se(se) ~ 0 + Intercept + (0 + Intercept | group))
fit_ma_empty <- brm(
  bf_ma,
  data = d_ma,
  prior = prior(student_t(7, 0, 0.25), class = "sd", group = "group") +
    prior(normal(0, 0.5), class = "b"),
  chains = 0,
  control = list(adapt_delta = .9999, max_treedepth = 15),
  file = here("Models/RICLPM-2L-stan/brms/brm-ma-empty")
)

cluster <- new_cluster(4)
cluster_library(cluster, c("dplyr", "brms", "here", "stringr"))
cluster_copy(cluster, "fit_ma_empty")

run_MA <- function(data, cluster, brms_empty) {
  fit_ma <- data %>%
    group_by(Parameter) %>%
    mutate(i = cur_group_id()) %>%
    partition(cluster) %>%
    summarise(
      fit = list(
        update(
          brms_empty,
          newdata = cur_data(),
          control = list(adapt_delta = .9999, max_treedepth = 15),
          iter = 15000, warmup = 5000, 
          refresh = 0,
        )
      )
    ) %>% 
    collect()
  
  fit_ma
}


fit_ma <- run_MA(d_ma, cluster, fit_ma_empty)

```

## Plots results
Let's look at the key parameters

* beta[1] = beta_x, x <- x
* beta[2] = gamma_x, x <- y
* beta[3] = gamma_y, y <- x
* beta[4] = beta_y, y <- y

* psifree[1:2] random intercepts
* psifree[3:8] ws latent variances

* sd_1[1:4] = game-level random effects for beta[1:4]

Plot estimates + 95% CIs vs true parameters values.
```{r, echo = FALSE}
tmp <- coef_sum %>% filter(grepl("^beta", variable))

# Fixed effects
tmp_multi <- data.frame(
    variable = paste0("betafree[", 1:4, "]"),
    map_df(fit_ma$fit, function(x) posterior_summary(x)[1, ])
)

# use the mean of the sampled effects as true value
tmp$theta <- d %>% 
    select(beta_2x, gamma_2x, gamma_2y, beta_2y) %>%
    apply(2, mean)

ggplot(
    tmp,
    aes(mean, variable)
    ) + 
    geom_point(aes(color = "RICLPM-2L-Stan")) +
    geom_linerange(aes(xmin = `2.5%`, xmax = `97.5%`, color = "RICLPM-2L-Stan")) +
    geom_point(
        data = tmp_multi, 
        aes(x = Estimate, color = "lavaan multi + MA"),
        position = position_nudge(y = -0.1)
        ) +
    geom_linerange(
        data = tmp_multi, 
        aes(
            x = Estimate, 
            xmin = `Q2.5`,
            xmax = `Q97.5`, 
            color = "lavaan multi + MA"),
        position = position_nudge(y = -0.1)
        ) +
    geom_point(aes(x = theta, color = "true value")) +
    labs(
        title = "Latent within effects", 
        subtitle = "linerange = 95% CI"
    )
```

```{r, echo = FALSE}
tmp3 <- coef_sum %>% filter(grepl("^sd", variable))
tmp3$theta <- with(
    params, 
    c(
        beta_x_sd, gamma_x_sd, 
        gamma_y_sd, beta_y_sd
    )
)

tmp_multi <- data.frame(
    variable = paste0("sd_1[", 1:4, "]"),
    map_df(fit_ma$fit, function(x) posterior_summary(x)[2, ])
)

ggplot(
    tmp3,
        aes(mean, variable)
    ) + 
    geom_point(aes(color = "RICLPM-2L-Stan")) +
    geom_linerange(aes(xmin = `2.5%`, xmax = `97.5%`, color = "RICLPM-2L-Stan")) +
    geom_point(
        data = tmp_multi, 
        aes(x = Estimate, color = "lavaan multi + MA"),
        position = position_nudge(y = -0.1)
        ) +
    geom_linerange(
        data = tmp_multi, 
        aes(
            x = Estimate, 
            xmin = `Q2.5`,
            xmax = `Q97.5`, 
            color = "lavaan multi + MA"),
        position = position_nudge(y = -0.1)
        ) +
    geom_point(aes(x = theta, color = "true value")) +
    labs(
        title = "Game-level random effects (betas)", 
        subtitle = "linerange = 95% CI"
    )
```

I didn't meta-analyze the random intercepts and latent variances, so this is only the Stan two-level model.
```{r, echo = FALSE}
tmp2 <- coef_sum %>% filter(grepl("^psi", variable))
tmp2$theta <- with(
    params, 
    c(
        sd_x_RE, sd_y_RE, 
        sd_wx1, sd_wy1,
        sd_wx2, sd_wy2,
        sd_wx3, sd_wy3
    )
)

ggplot(
    tmp2,
    aes(mean, variable)
    ) + 
    geom_point(aes(color = "est")) +
    geom_linerange(aes(xmin = `2.5%`, xmax = `97.5%`, color = "est")) +
    geom_point(aes(x = theta, color = "true value")) +
    labs(
        title = "Random intercepts and latent variances", 
        subtitle = "linerange = 95% CI"
    )
```

## Simulation study: lavaan multigroup + MA
Now let's do a quick Monte Carlo simulation of the whole lavaan multigroup + MA pipeline, using the random effects DGP (laten within regression vary by game).
```{r, include = FALSE}
one_simulation <- function(i = 1) {
  cat(i, " ")
  d <- do.call(sim_RICLPM_data, params)
  fit_multi <- lavaan(
      riclpm_constrained_multigroup,
      data = d,
      group = "cluster",
      group.equal = c(
          "residuals", 
          "residual.covariances",
          "lv.variances", 
          "lv.covariances"),
      meanstructure = TRUE,
      int.ov.free = TRUE
    )
  pars_riclpm_mg <- get_lavaan_pars(fit_multi)
  d_ma <- pars_riclpm_mg %>%
    filter(Type == "Unstandardized", str_detect(Parameter, " ~ ")) %>%
    filter(Parameter %in% c("wx2 ~ wx1", "wx2 ~ wy1", "wy2 ~ wy1", "wy2 ~ wx1"))
  fit_ma <- run_MA(d_ma, cluster, fit_ma_empty)

  sum_fixed <- data.frame(
      variable = paste0("betafree[", 1:4, "]"),
      map_df(fit_ma$fit, function(x) posterior_summary(x)[1, ])
  )
  sum_random <- data.frame(
    variable = paste0("sd_1[", 1:4, "]"),
    map_df(fit_ma$fit, function(x) posterior_summary(x)[2, ])
  )

  out <- rbind(sum_fixed, sum_random)
  out$i <- i
  saveRDS(
    out, 
    here(paste0("Models/RICLPM-2L-stan/sim_res/sim_res-", i, ".Rds"))
  )
  out
}
```

500 simulations should give a Monte carlo standard error of approx 0.01 around 0.95.

```{r}
p <- 0.95
sqrt((p * (1 - p)/500))
```

```{r}
nsim <- 500
# only run the simulation if they haven't all been completed already
# there's no error handling, so just rerun this chunk if there's a crash
n_completed_sims <- length(dir(here("Models/RICLPM-2L-stan/sim_res/")))
if(n_completed_sims != nsim) {
  sim_res <- map_df((n_completed_sims + 1):500, one_simulation)
}
```

```{r}
# load the sim results
res_files <- dir(here("Models/RICLPM-2L-stan/sim_res/"))
sim_res <- map_df(
  res_files, 
  function(file) readRDS(here("Models/RICLPM-2L-stan/sim_res/", file))
)
```

Summarize sim results
```{r, sim-summary}
sim_res_sum <- sim_res %>% 
  mutate(
    theta = case_when(
      variable == "betafree[1]" ~ params$beta_2x,
      variable == "betafree[2]" ~ params$gamma_2x,
      variable == "betafree[3]" ~ params$gamma_2y,
      variable == "betafree[4]" ~ params$beta_2y,
      variable == "sd_1[1]" ~ params$beta_x_sd,
      variable == "sd_1[2]" ~ params$gamma_x_sd,
      variable == "sd_1[3]" ~ params$gamma_y_sd,
      variable == "sd_1[4]" ~ params$beta_y_sd
    ),
  ) %>%
  group_by(variable) %>%
  summarise(
    "mean(est)" = mean(Estimate), 
    theta = mean(theta),
    "RB(est)" = (`mean(est)` - theta)/theta,
    "mean(se)" = mean(Est.Error), 
    "sd(est)" = sd(Estimate),
    "RB(se)" = (`mean(se)` - `sd(est)`)/`sd(est)`,
    CI_cover = mean(Q2.5 < theta & Q97.5 > theta)
    )
```

```{r}
kable(sim_res_sum, digits = 3)
```

I'd say that the model is pretty OK. 

## Conclusions
**Stan model**

- These results are pretty promising
- Sampling is inefficient, probably too slow for large data.
- Should probably use correlated random effects
- Let more parameters vary by game?
- Should check if SEs/CIs are correct
    - Slow simulation

**Lavaan multigroup + MA**

- Point ests are pretty close to stan model, but SEs are narrower.
- <del>Should run a simulation to check the CIs for this model, wouldn't take too long.</del>
  - Ran 500 simulations, the results are pretty OK.
- This approach is much more feasible compared to the Stan model
