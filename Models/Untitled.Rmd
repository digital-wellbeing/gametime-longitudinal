---
title: 'Proposed models for within-person associations of game play time and well-being'
author: "Matti"
date: "Today"
output: html_document
---

```{r setup, include=FALSE}
# Document and MC sampler settings
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores(logical = FALSE))
options(brms.backend = "cmdstanr")
mcmc_opts <- list(
  iter = 3500, warmup = 1500,
  control = list(adapt_delta = .90, max_treedepth = 10)
)
# Run this to delete fitted models and refit
# unlink(list.files(pattern = "brm-.*\\.rds"))
```

```{r packages, results = 'hide'}
library(lavaan)
library(lme4)
library(broom.mixed)
library(dagitty)
library(broom)
library(brms)
library(faux)  # rnorm_multi()
library(tidyverse)
```

# Preface

Our aim is to examine the within-person association between quantity of video game play (hours played) and well-being (primarily negative and positive subscales of SPANE, secondarily CSAS). Additionally, we want to examine how the players' motivations potentially moderate the relationship between game play and well-being. Here, we propose and specify a set of models for this examination.

The data will consist of up to three measurement occasions of the survey responses (SPANE, CSAS, motivations) per person, separated by about two weeks. In addition to this, we will have each player's gameplay telemetry (session times) for that 6 week period, which will be aggregated to hours played for each two week period corresponding to the survey responses. We will likely aggregate gameplay telemetry to average hours per day in each two week window, to account for slight variations in the response windows between participants. We expect significant drop-out between waves.

With these data, our primary questions relate to

- To what extent do changes in time spent playing predict changes in well-being within individuals?
- Motivations
- Time

# Example data

We first simulate data under different assumptions about sample sizes and drop-out to examine models' behaviour. This would optimally be extended to a three-level situation. Improvements could be made to e.g. dropout function etc. Currently dropout is just a x% chance of that wave (2 or 3) missing.

```{r}
# This function allows for a bunch of stuff we don't need
sim <- function(
  N = 50, n = 3, dropout = 0,
  # Population-level means and standard deviations
  mu_x = 0, mu_y = 0, sigma_x = 1, sigma_y = 1,
  # Population level effects (xy = x's effect on y, xl = x lag)
  b_xlx = 0, b_xly = 0, b_yly = 0, b_ylx = 0, b_xy = 0, b_yx = 0,
  # Standard deviations of person-specific parameters
  tau_x = 0, tau_y = 0, 
  tau_xlx = 0, tau_xly = 0, tau_yly = 0, tau_ylx = 0, tau_xy = 0, tau_yx = 0
) {
  # Create subject-specific parameters
  rx <- rnorm_multi(
    n = N, vars = 8,
    mu = 0, 
    sd = c(tau_x, tau_y, tau_xlx, tau_xly, tau_yly, tau_ylx, tau_xy, tau_yx), 
    r = 0,
    varnames = c("u_x", "u_y", "u_xlx", "u_xly", "u_yly", "u_ylx", "u_xy", "u_yx")
  ) %>% 
    rowid_to_column(var = "pid") %>% 
    as_tibble()
  
  # Create data. This is hairy because allows lagged terms.
  dat <- rx %>% 
    expand_grid(time = 0:(n-1)) %>% 
    rowwise() %>% 
    mutate(
      # First with lag effects zero for first time point
      # Write it out for clarity
      x = rnorm(
        1, 
        (mu_x+u_x) + (b_ylx+u_ylx)*0 + (b_xlx+u_xlx)*0 + (b_yx+u_yx)*0, 
        sigma_x
      ),
      y = rnorm(
        1, 
        (mu_y+u_y) + (b_xly+u_xly)*0 + (b_yly+u_yly)*0 + (b_xy+u_xy)*x, 
        sigma_y
      )
    ) %>% 
    group_by(pid) %>% 
    mutate(x_lag = lag(x, 1), y_lag = lag(y, 1)) %>% 
    rowwise() %>% 
    mutate(
      # Then apply lagged effects to timepoints after first one
      x = ifelse(
        is.na(x_lag),
        x,
        rnorm(
          1,
          (mu_x+u_x) + (b_ylx+u_ylx)*y_lag +
            (b_xlx+u_xlx)*x_lag + (b_yx+u_yx)*y,
          sigma_x
        )
      ),
      y = ifelse(
        is.na(y_lag),
        y,
        rnorm(
          1,
          (mu_y+u_y) + (b_xly+u_xly)*x_lag +
            (b_yly+u_yly)*y_lag + (b_xy+u_xy)*x,
          sigma_y
        )
      )
    ) %>%
    select(pid, time, x, y) %>% 
    ungroup()
  
  # Dropout wow
  dat[dat$time>0,] <- dat[dat$time>0,] %>% 
    rowwise() %>% 
    mutate(
      across(
        x:y, 
        ~ifelse(sample(c(FALSE, TRUE), 1, prob = c(1-dropout, dropout)), NA, .)
      )
    ) %>% 
    ungroup()
    dat
}
```

```{r eval = FALSE}
# Let's see if this works

# Dropout
table(is.na(sim(n = 100, dropout = .5)$x))

# Simple correlation
expand_grid(run = 1:10, b_xy = 1) %>% 
  rowwise() %>% 
  mutate(data = list(sim(b_xy = b_xy))) %>% 
  mutate(tab = list(lm(y ~ x, data = data) %>% tidy)) %>% 
  select(-data) %>% 
  unnest(tab) %>% 
  bind_rows(.id = "Run") %>% 
  group_by(term) %>%  
  summarise(m = mean(estimate), sd = sd(estimate))

# Random intercepts and fixed correlation
expand_grid(run = 1:10, nesting(b_xy = 1, tau_y = 1)) %>% 
  rowwise() %>% 
  mutate(data = list(sim(b_xy = b_xy))) %>% 
  mutate(tab = list(lmer(y ~ x + (1 | pid), data = data) %>% tidy)) %>% 
  select(-data) %>% 
  unnest(tab) %>% 
  bind_rows(.id = "Run") %>% 
  group_by(term) %>%  
  summarise(m = mean(estimate), sd = sd(estimate))
```

# Two-level model

We simulate data for 1200 people and 3 time points, with 25% dropout.

```{r}
set.seed(1)
dat <- sim(
  N = 1000, n = 3, dropout = .25,
  b_xy = .25, 
  tau_x = 1, tau_xy = .33,
)
```

This is now fitted to this univariate outcome but we should fit it to the three well being variables simultaneously to borrow strength across the models in the random effects.

```{r}
# Between and within-person centering of x and y
dat <- dat %>% 
  group_by(pid) %>% 
  mutate(
    # Person means (between-deviates)
    xb = mean(x, na.rm = TRUE), 
    yb = mean(y, na.rm = TRUE), 
    # Within-deviates
    xw = x-xb, 
    yw = y-yb
  ) %>% 
  ungroup()
model <- bf(yw ~ xw + xb + (xw | pid), family = gaussian())
fit <- brm(
  model,
  data = dat,
  file = "brm-model-1", 
  save_pars = save_pars(group = FALSE),
  iter = mcmc_opts$iter, warmup = mcmc_opts$warmup,
  control = mcmc_opts$control
)
summary(fit)
```
