# Main analysis

This document contains the main analyses presented in the manuscript.

We first load the required R packages.

```{r packages, results = "hide", cache = FALSE}
library(knitr)
library(scales)
library(DT)
library(kableExtra)
library(ggpp)
library(bayestestR)
library(brms)
library(here)
library(ggtext)
library(ggstance)
library(ggdist)
library(patchwork)
library(lavaan)
library(showtext)
library(multidplyr)
library(tidyverse)
library(tidybayes)
library(janitor)
```

Define plotting, table, and parallel processing options.

```{r settings, cache = FALSE}
# parallel computations
MAX_CORES <- as.numeric(Sys.getenv("MAX_CORES"))
if (is.na(MAX_CORES)) MAX_CORES <- parallel::detectCores(logical = FALSE)
cluster <- new_cluster(MAX_CORES)

# load packages on clusters
cluster_library(cluster, c("dplyr", "lavaan"))

# MCMC settings
options(mc.cores = 1)
if (require("cmdstanr")) options(brms.backend = "cmdstanr")

# Plotting options
Font <- "Titillium Web"
font_add_google(Font, Font)
theme_set(
  theme_linedraw(
    base_family = Font,
    base_size = 12
  ) +
    theme(
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank()
    )
)
col1 <- "#2980b9"
col2 <- "#2980b9"
```

We analyse the data cleaned previously.

```{r}
data_path <- here("Data", "cleaned_data.rds")
if (file.exists(data_path)) {
  d <- read_rds(file = data_path)
} else {
  stop(str_glue("{data_path} doesn't exist, run `01-clean.Rmd` to create it."))
}

# Make wave a nicely labelled factor
d <- d %>%
  mutate(Wave = factor(wid, levels = 1:3, labels = paste0("Wave ", 1:3)))
```

For all analyses, game time indicates average number of hours per day. The telemetry indicates total hours in the two week window, so we divide that by 14 to talk about average hours per day.

```{r}
d <- d %>%
  mutate(
    Hours = Hours / 14,
    hours_est = hours_est / 14
  )
```

## Variables over time

Hours played per week is cut at a reasonable value for the figures:

```{r}
d %>%
  mutate(Hours_over_3 = Hours > 3) %>%
  tabyl(Hours_over_3) %>%
  adorn_pct_formatting()
```

```{r variables-over-time, fig.width = 8, fig.height = 8, fig.cap = "Density plots of key variables over time for each game."}
tmp <- d %>%
  select(
    Game, Wave, pid,
    Hours, Affect, `Life satisfaction`,
    Intrinsic, Extrinsic
  ) %>%
  pivot_longer(Hours:Extrinsic) %>%
  drop_na(value) %>%
  filter(!(name == "Hours" & value > 3)) %>%
  mutate(name = fct_inorder(name))

tmp %>%
  ggplot(
    aes(
      Wave,
      value,
      fill = Game,
      color, Game,
      group = Game
    )
  ) +
  scale_x_discrete(labels = 1:3, expand = expansion(c(0.1, .1))) +
  scale_color_manual(
    values = c(col1, col2, col1, col2, col1, col2, col1),
    aesthetics = c("fill", "color", "slab_color")
  ) +
  scale_y_continuous(
    "Value",
    breaks = pretty_breaks(),
    expand = expansion(.025)
  ) +
  geom_blank() +
  stat_halfeye(
    alpha = .33,
    height = .02,
    normalize = "panels",
    adjust = 1.1,
    point_interval = NULL,
    show.legend = FALSE
  ) +
  # only the outline (hackish)
  stat_halfeye(
    alpha = 1,
    height = .02,
    normalize = "panels",
    aes(slab_color = Game),
    slab_size = 0.5,
    fill = NA,
    adjust = 1.1,
    point_interval = NULL,
    show.legend = FALSE
  ) +
  stat_summary(
    fun.data = mean_cl_normal,
    fatten = 1.25
  ) +
  stat_summary(
    fun = mean,
    geom = "line",
    size = .33
  ) +
  facet_grid(name ~ Game, scales = "free_y") +
  theme(
    legend.position = "none",
    strip.text.x = element_text(size = 8)
  )
```

Then take a look at a simple model of change over time for each variable. Note that we can't use varying slopes with lmer because there's not enough data, so just random intercepts for players.

```{r}
library(lme4)
library(broom.mixed)
parameters_change_over_time <- d %>%
  select(
    Game, pid, wid,
    Hours, Intrinsic, Extrinsic,
    Affect, `Life satisfaction`
  ) %>%
  # Put intercept at first wave
  mutate(Wave = wid - 1) %>%
  pivot_longer(Hours:`Life satisfaction`, names_to = "Variable") %>%
  group_by(Variable) %>%
  summarise(
    lmer(value ~ Wave + (1 | pid) + (1 + Wave | Game), data = cur_data()) %>%
      tidy(., "fixed", conf.int = TRUE)
  )
parameters_change_over_time %>%
  mutate(across(where(is.numeric), ~ format(round(.x, 2), nsmall = 2))) %>%
  mutate(Result = str_glue("{estimate}, 95%CI [{conf.low}, {conf.high}]")) %>%
  select(Variable, term, Result) %>%
  pivot_wider(names_from = term, values_from = Result) %>% 
  kbl(caption = "Change over time parameter estimates") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

## Models

### Simple correlation

Regression coefficients (standardized and raw) of well-being predicted from game play need satisfaction, and intrinsic motivation (enjoyment).

```{r simple-regression-coefficients, fig.width = 8, fig.height = 8, fig.cap = "Bivariate regression coefficients of models predicting well-being. Columns indicate predictors, and the two rows are the different well-being outcome variables."}
d %>%
  select(
    Game, pid, wid, Wave,
    Hours, Intrinsic, Extrinsic,
    Affect, `Life satisfaction`
  ) %>%
  pivot_longer(
    c(Affect, `Life satisfaction`),
    names_to = "Outcome", values_to = "Outcome_value"
  ) %>%
  pivot_longer(
    c(Hours, Intrinsic, Extrinsic),
    names_to = "Predictor", values_to = "Predictor_value"
  ) %>%
  group_by(Game, Outcome, Predictor, Wave) %>%
  summarise(
    std = list(tidy(lm(scale(Outcome_value) ~ scale(Predictor_value), data = cur_data()), conf.int = TRUE)),
    raw = list(tidy(lm(Outcome_value ~ Predictor_value, data = cur_data()), conf.int = TRUE)),
  ) %>%
  pivot_longer(std:raw, names_to = "Model") %>%
  unnest(value) %>%
  filter(term != "(Intercept)") %>%
  mutate(Panel = str_glue("{Outcome} ({Model})")) %>%
  mutate(
    Panel = factor(
      Panel,
      levels = c(
        "Affect (raw)", "Life satisfaction (raw)",
        "Affect (std)", "Life satisfaction (std)"
      )
    )
  ) %>%
  ggplot(aes(estimate, Game, col = Wave, shape = Model)) +
  geom_vline(xintercept = 0, lty = 2, size = .25) +
  scale_x_continuous(
    "Bivariate regression coefficient (95%CI)",
    breaks = pretty_breaks()
  ) +
  geom_pointrangeh(
    aes(xmin = conf.low, xmax = conf.high),
    size = .4,
    position = position_dodge2v(.3)
  ) +
  facet_grid(Outcome ~ Predictor, scales = "free_x") +
  theme(
    axis.title.x = element_markdown(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )
```

## RICLPM

Wrangle data to a format where lavaan model is easier to map to variable pairs: Wide format with different rows for outcomes (well-being) and predictors (hours, needs, motivations).

```{r}
d_riclpm_long <- d %>%
  select(
    Game, pid, wid,
    Hours, hours_est,
    Intrinsic, Extrinsic,
    Affect, `Life satisfaction`
  ) %>%
  # Long format on well-being scores (outcomes)
  pivot_longer(
    c(Affect, `Life satisfaction`),
    names_to = "y_var", values_to = "y"
  ) %>%
  # Long format on other variables (predictors)
  pivot_longer(
    c(Hours, hours_est, Intrinsic, Extrinsic),
    names_to = "x_var", values_to = "x"
  )
d_riclpm_wide <- d_riclpm_long %>%
  pivot_wider(names_from = wid, values_from = c(x, y), names_sep = "")
```

### Cross-lagged scatterplots

```{r riclpm-crosslag-scatter-hours, fig.width = 8, fig.height = 6.5, fig.cap = "Scatterplots of well-being (rows indicate variables and waves) on average hours played per day during the previous wave. Regression lines are GAM fitted lines and 95%CIs."}
Order <- tibble(
  y_var = rep(c("Affect", "Life satisfaction"), each = 2),
  wid = c(2, 3, 2, 3),
  Panel = c(
    "Affect[plain('[Wave 2]')]",
    "Affect[plain('[Wave 3]')]",
    "LS[plain('[Wave 2]')]",
    "LS[plain('[Wave 3]')]"
  ),
  Panel_label = fct_inorder(Panel)
)

d_riclpm_plots <- d_riclpm_long %>%
  # Take out hours per day over 3 for these plots
  mutate(x = if_else(str_detect(x_var, "ours") & x > 3, NaN, x)) %>%
  arrange(Game, pid, x_var, wid) %>%
  group_by(Game, pid, x_var, y_var) %>%
  mutate(lag_x = lag(x)) %>%
  left_join(Order) %>%
  ungroup() %>%
  filter(wid > 1)

d_riclpm_plots %>%
  filter(x_var == "Hours") %>%
  ggplot(aes(lag_x, y)) +
  scale_x_continuous(
    "Hours played per day at previous wave",
    breaks = pretty_breaks(3)
  ) +
  scale_y_continuous(
    "Well-being at current wave",
    breaks = pretty_breaks()
  ) +
  geom_point(size = .2, alpha = .2, shape = 1, col = col1) +
  geom_smooth(
    method = "gam", size = .4,
    color = "black",
    alpha = .33, show.legend = FALSE
  ) +
  facet_grid(
    Panel_label ~ Game,
    scales = "free_y",
    labeller = labeller(.rows = label_parsed)
  ) +
  theme(
    aspect.ratio = 1,
    panel.grid = element_blank(),
    strip.text.x = element_text(size = 8)
  )
```

```{r riclpm-crosslag-scatter-hours-estimated, fig.width = 8, fig.height = 6.5, fig.cap = "Scatterplots of well-being (rows indicate variables and waves) on estimated average hours played per day during the previous wave. Regression lines are GAM fitted lines and 95%CIs."}
# Plots with other predictors
p_tmp_0 <- last_plot() %+%
  filter(d_riclpm_plots, x_var == "hours_est") +
  scale_x_continuous(
    "Estimated hours played per day at previous wave",
    breaks = pretty_breaks()
  )
p_tmp_0
```

```{r riclpm-crosslag-scatter-intrinsic, fig.width = 8, fig.height = 6.5, fig.cap = "Scatterplots of well-being (rows indicate variables and waves) on intrinsic motivation during the previous wave. Regression lines are GAM fitted lines and 95%CIs."}
p_tmp_1 <- last_plot() %+%
  filter(d_riclpm_plots, x_var == "Intrinsic") +
  scale_x_continuous(
    "Intrinsic motivation at previous wave",
    breaks = pretty_breaks()
  )
p_tmp_1
```

```{r riclpm-crosslag-scatter-extrinsic, fig.width = 8, fig.height = 6.5, fig.cap = "Scatterplots of well-being (rows indicate variables and waves) on extrinsic motivation during the previous wave. Regression lines are GAM fitted lines and 95%CIs."}
p_tmp_2 <- last_plot() %+%
  filter(d_riclpm_plots, x_var == "Extrinsic") +
  scale_x_continuous(
    "Extrinsic motivation at previous wave",
    breaks = pretty_breaks()
  )
p_tmp_2
```

```{r riclpm-crosslag-scatter-motivations, fig.width = 8, fig.height = 12, fig.cap = "Scatterplots of well-being (rows indicate variables and waves) on intrinsic and extrinsic motivation during the previous wave. Regression lines are GAM fitted lines and 95%CIs."}
p_tmp_1 / p_tmp_2
```

### Fit one model to all data

First fit RICLPM to all data. Separately to the two well-being outcomes, and each predictor (hours, subjective scales). Constrain (cross)lagged parameters

Syntax based on <https://jeroendmulder.github.io/RI-CLPM/lavaan.html>

```{r}
riclpm_constrained <- "
  # Create between components (random intercepts)
  RIx =~ 1*x1 + 1*x2 + 1*x3
  RIy =~ 1*y1 + 1*y2 + 1*y3

  # Create within-person centered variables
  wx1 =~ 1*x1
  wx2 =~ 1*x2
  wx3 =~ 1*x3
  wy1 =~ 1*y1
  wy2 =~ 1*y2
  wy3 =~ 1*y3

  # Estimate the lagged effects between the within-person centered variables (constrained).
  wx2 ~ bx*wx1 + gx*wy1
  wy2 ~ gy*wx1 + by*wy1
  wx3 ~ bx*wx2 + gx*wy2
  wy3 ~ gy*wx2 + by*wy2

  # Estimate the covariance between the within-person centered
  # variables at the first wave.
  wx1 ~~ wy1 # Covariance

  # Estimate the covariances between the residuals of the
  # within-person centered variables (the innovations).
  wx2 ~~ wy2
  wx3 ~~ wy3

  # Estimate the variance and covariance of the random intercepts.
  RIx ~~ RIx
  RIy ~~ RIy
  RIx ~~ RIy

  # Estimate the (residual) variance of the within-person centered variables.
  wx1 ~~ wx1 # Variances
  wy1 ~~ wy1
  wx2 ~~ wx2 # Residual variances
  wy2 ~~ wy2
  wx3 ~~ wx3
  wy3 ~~ wy3
"
```

```{r}
cluster_copy(cluster, "riclpm_constrained")
fit_riclpm_all <- d_riclpm_wide %>%
  group_by(y_var, x_var) %>%
  partition(cluster) %>%
  summarise(
    fit = lavaan(
      riclpm_constrained,
      data = cur_data(),
      missing = "ml",
      meanstructure = TRUE,
      int.ov.free = TRUE
    ) %>% list()
  ) %>%
  collect()

get_lavaan_pars <- function(x) {
  bind_rows(
    parameterestimates(x) %>%
      mutate(Type = "Unstandardized"),
    standardizedsolution(x) %>%
      rename(est = est.std) %>%
      mutate(Type = "Standardized")
  ) %>%
    as_tibble() %>%
    unite("Parameter", c(lhs, op, rhs), sep = " ", remove = FALSE)
}

pars_riclpm_avg <- fit_riclpm_all %>%
  mutate(pars = map(fit, get_lavaan_pars)) %>%
  select(-fit)
```

```{r}
pars_riclpm_avg %>%
  ungroup() %>%
  unnest(pars) %>%
  filter(
    Parameter %in% c("wy2 ~ wx1", "wx2 ~ wy1", "wy2 ~ wy1", "wx2 ~ wx1"),
    Type == "Unstandardized"
  ) %>%
  mutate(across(where(is.numeric), ~ format(round(.x, 2), nsmall = 2))) %>%
  mutate(Result = str_glue("{est}, [{ci.lower}, {ci.upper}]")) %>%
  select(y_var, x_var, Parameter, Result) %>%
  pivot_wider(names_from = Parameter, values_from = Result) %>%
  kbl(
    caption = "RICLPM regression parameters from pooled model."
  ) %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

### Separate models per game

Fit the above model separately to each game.

```{r}
fit_riclpm_sep <- d_riclpm_wide %>%
  group_by(y_var, x_var, Game) %>%
  partition(cluster) %>%
  summarise(
    fit = lavaan(
      riclpm_constrained,
      data = cur_data(),
      missing = "ml",
      meanstructure = TRUE,
      int.ov.free = TRUE
    ) %>% list()
  ) %>%
  collect()
pars_riclpm_sep <- fit_riclpm_sep %>%
  mutate(pars = map(fit, get_lavaan_pars)) %>%
  select(-fit)
```

Look at estimates

```{r riclpm-regression-estimates, fig.height = 5, fig.width = 8, fig.cap = "RICLPM regression coefficient estimates (lagged and cross-lagged paths, parameter indicated by row) for four predictors (columns). Colors indicate different models; independent fits to games, or a single model fitted to all games' pooled data."}
# Table of RICLPM parameters from all models
pars_riclpm <- pars_riclpm_sep %>%
  mutate(Model = "Independent") %>%
  bind_rows(pars_riclpm_avg %>% mutate(Model = "Pooled", Game = "Average")) %>%
  ungroup() %>%
  unnest(pars) %>%
  # Take regression parameters at first interval, and
  # covariance parameters of interest
  filter(
    (str_detect(Parameter, " ~ ") & !str_detect(Parameter, "3")) |
      Parameter %in% c("RIx ~~ RIy", "wx1 ~~ wy1", "wx2 ~~ wy2", "wx3 ~~ wy3")
  ) %>%
  mutate(Game = fct_relevel(Game, "Average")) %>%
  select(-c(lhs:label, z))

# Plot of regression parameters (autocorrelations and crosslags; raw)
pars_riclpm %>%
  rename(Predictor = x_var, Outcome = y_var) %>%
  filter(Type == "Unstandardized", str_detect(Parameter, " ~ ")) %>%
  ggplot(
    aes(
      est, Game, shape = Outcome,
      col = Model, xmin = ci.lower, xmax = ci.upper
    )
  ) +
  scale_x_continuous(
    "Estimated parameter",
    breaks = pretty_breaks()
  ) +
  geom_vline(xintercept = 0, size = .2, lty = 2) +
  geom_pointrangeh(position = position_dodge2v(.5), size = .4) +
  facet_grid(Parameter ~ Predictor, scales = "free_x", labeller = label_both)
```

Plots of covariance parameters (raw)

```{r riclpm-covariance-estimates, fig.height = 5, fig.width = 8, fig.cap = "RICLPM raw covariance parameter estimates, legend as above."}
pars_riclpm %>%
  rename(Predictor = x_var, Outcome = y_var) %>%
  filter(
    Type == "Unstandardized",
    str_detect(Parameter, " ~~ ")
  ) %>%
  ggplot(
    aes(
      x = est,
      y = Game,
      shape = Outcome,
      col = Model,
      xmin = ci.lower,
      xmax = ci.upper
    )
  ) +
  scale_x_continuous(
    "Estimated parameter",
    breaks = pretty_breaks()
  ) +
  geom_vline(xintercept = 0, size = .2, lty = 2) +
  geom_pointrangeh(
    position = position_dodge2v(.5),
    size = .4
  ) +
  facet_grid(
    Parameter ~ Predictor,
    scales = "free_x",
    labeller = label_both
  )
```

## Meta-analyses

Number of observations/participants per model

```{r}
fit_riclpm_sep %>%
  mutate(N = map_dbl(fit, nobs) %>% comma()) %>%
  select(-fit) %>%
  pivot_wider(
    names_from = x_var,
    values_from = N,
    names_glue = "{x_var} {.value}"
  ) %>%
  rename(Outcome = y_var) %>%
  arrange(Outcome, Game) %>%
  kbl(caption = "Sample sizes per RICLPM") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

Then conduct all meta-analyses (for each y_var-x_var pair, parameter of interest, and type of parameter (standardized, unstandardized)) of the game-specific RICLPM parameters.

```{r fit-meta-analyses, results = 'hide', cache = FALSE}
# Select variables from RICLPM parameters to data for MA
d_ma <- pars_riclpm %>%
  filter(
    Model == "Independent",
    str_detect(Parameter, " ~ ")
  ) %>%
  select(Type, y_var, x_var, Game, Parameter, est, se, ci.lower, ci.upper)

# Save/load meta-analyses in one file
file_path <- here("Temp", "brms-meta-analyses.rds")
if (file.exists(file_path)) {
  fit_ma <- read_rds(file = file_path)
} else {
  # Compile meta-analytic brms/Stan model
  bf_ma <- bf(est | se(se) ~ 0 + Intercept + (0 + Intercept | Game))
  fit_ma_empty <- brm(
    bf_ma,
    data = d_ma,
    prior = prior(student_t(7, 0, 0.25), class = "sd", group = "Game") +
      prior(normal(0, 0.5), class = "b"),
    chains = 0,
    control = list(adapt_delta = .999)
  )
  # Fit meta-analyses by updating the compiled model.
  cluster_library(cluster, c("brms", "dplyr"))
  cluster_copy(cluster, "fit_ma_empty")
  fit_ma <- d_ma %>%
    group_by(x_var, y_var, Parameter, Type) %>%
    partition(cluster) %>%
    summarise(
      fit = list(
        update(
          fit_ma_empty,
          newdata = cur_data(),
          control = list(adapt_delta = .9999),
          iter = 10000, warmup = 5000,
          refresh = 0
        )
      )
    ) %>%
    collect() %>%
    ungroup()
  write_rds(fit_ma, file = file_path)
}

# Function to get varying and average effects' posteriors from brmsfit
get_ma_post <- function(x) {
  coef(x, summary = FALSE) %>%
    .[["Game"]] %>%
    .[, , 1] %>%
    as.data.frame() %>%
    cbind(fixef(x, summary = FALSE)) %>%
    as_tibble()
}
```

### Table of parameters

All the resulting parameters are listed in the table below.

```{r}
# Table of all parameters from meta-analyses
ma_pars <- fit_ma %>%
  mutate(out = map(fit, get_ma_post)) %>%
  mutate(
    out2 = map(
      out,
      ~ describe_posterior(.x, centrality = "mean", ci = 0.95) %>%
        rename(Game = Parameter)
    )
  ) %>%
  select(-fit, -out) %>%
  unnest(out2) %>%
  select(-CI, -starts_with("ROPE")) %>%
  mutate(Game = str_replace(Game, "Intercept", "Average"))

# Interactive table so reader can find what they're looking for
ma_pars %>% 
  mutate(
    pd = percent(pd, .1),
    across(x_var:Game, factor),
    across(where(is.numeric), ~round(.x, 5))
  ) %>% 
  datatable(
    filter = "top",
    class = "display"
  ) %>% 
  formatRound(c("Mean", "CI_low", "CI_high"), 2) %>% 
  formatStyle(TRUE, `font-size` = '12px')
```

### Average effects

This figure shows the average (across games) effects from meta-analyses of the game-specific lavaan fits ("partial pooling") and from the completely pooled lavaan model (one model fit to all games' data). Unstandardized parameters are shown.

```{r riclpm-ma-lavaan-averages, fig.width = 8, fig.height = 5, fig.cap = "Average RICLPM regression parameters from the pooled and meta-analytic models. Columns are different x variables, and rows different y variables. e.g. wy2 ~ wy1 indicates the lagged effect of y at previous timepoint on y at current timepoint."}
ma_pars %>%
  filter(Game == "Average", Type == "Unstandardized") %>%
  ggplot(aes(Mean, Parameter)) +
  scale_x_continuous(
    "Estimated parameter (95%CI)",
    breaks = pretty_breaks()
  ) +
  scale_color_discrete("Model") +
  geom_vline(xintercept = 0, lty = 2, size = .25) +
  geom_pointrangeh(
    aes(xmin = CI_low, xmax = CI_high, color = "Partially pooled")
  ) +
  geom_pointrangeh(
    data = pars_riclpm %>%
      filter(
        str_detect(Parameter, " ~ "),
        Type == "Unstandardized",
        Model == "Pooled"
      ),
    aes(x = est, xmin = ci.lower, xmax = ci.upper, color = "Pooled"),
    position = position_nudge(y = .15)
  ) +
  facet_grid(y_var ~ x_var)
```

### Hours <-> WB

Draw a forest plot of meta-analyses with hours

```{r}
# Table of nice labels in proper order
Order <- distinct(fit_ma, x_var, y_var, Parameter) %>%
  ungroup() %>%
  # Meta-analyses only for regression parameters
  filter(str_detect(Parameter, " ~ ")) %>%
  mutate(
    x_lab = case_when(
      x_var == "Hours" ~ "Play",
      x_var == "Intrinsic" ~ "Intrinsic",
      x_var == "Extrinsic" ~ "Extrinsic",
      x_var == "hours_est" ~ "Estimated~hours"
    ),
    y_lab = case_when(
      y_var == "Affect" ~ "Affect",
      y_var == "Life satisfaction" ~ "Life~satisfaction"
    ),
    Panel_label = case_when(
      Parameter == "wx2 ~ wx1" ~
        str_glue('{x_lab}[plain("[t-1]")]%->%{x_lab}[plain("[t]")]'),
      Parameter == "wy2 ~ wy1" ~
        str_glue('{y_lab}[plain("[t-1]")]%->%{y_lab}[plain("[t]")]'),
      Parameter == "wy2 ~ wx1" ~
        str_glue('{x_lab}[plain("[t-1]")]%->%{y_lab}[plain("[t]")]'),
      Parameter == "wx2 ~ wy1" ~
        str_glue('{y_lab}[plain("[t-1]")]%->%{x_lab}[plain("[t]")]')
    )
  ) %>%
  mutate(
    Parameter_order = factor(
      Parameter,
      levels = c("wy2 ~ wx1", "wx2 ~ wy1", "wy2 ~ wy1", "wx2 ~ wx1")
    )
  ) %>%
  arrange(Parameter_order, y_var) %>%
  mutate(Panel_label = fct_inorder(Panel_label))

#' Summarize meta-analyses
#' @param object a grouped df with all the brmsfits; e.g., fit_ma
#'
#' @return a list with
#'  - `summary`:
#'  - `draws`: the posterior draws
summarize_ma <- function(object) {
  
  # Data for plotting meta-analyses' posterior distributions
  p_data <- object %>%
    mutate(out = map(fit, get_ma_post)) %>%
    select(-fit) %>%
    unnest(out) %>%
    rename(Average = Intercept) %>%
    pivot_longer(`AC:NH`:Average, names_to = "Game") %>%
    mutate(Game = fct_relevel(Game, "Average")) %>%
    ungroup() %>%
    left_join(Order)
  
  # Summaries of posterior distributions
  fit_ma_sum <- p_data %>%
    group_by(y_var, x_var, Parameter, Type, Game, Panel_label) %>%
    summarise(
      describe_posterior(
        value,
        test = c("pd"),
        centrality = "mean"
      ) %>% select(-Parameter)
    ) %>%
    ungroup() %>%
    mutate(
      across(
        c(Mean, CI_low, CI_high),
        .fns = list(r = ~ format(round(., 2), nsmall = 2))
      )
    ) %>%
    mutate(Res = str_glue("{Mean_r} [{CI_low_r}, {CI_high_r}]")) %>%
    # Ordered labels
    left_join(Order) %>%
    mutate(Game = fct_relevel(Game, "Average"))
  
  list(
    summary = fit_ma_sum,
    draws = p_data
  )
}

#' Function to draw forest plots
#' @param object object created using `summarize_ma`
#' @param type
#' @param x_var
#' @param parameters
#' @param lavaan
#'
#' @return a ggplot2 object
forest_plot <- function(object,
                        type = "Unstandardized",
                        x_var = "Hours",
                        parameters = c("wy2 ~ wx1", "wx2 ~ wy1"),
                        x_limits = c(-0.2, 0.2),
                        lavaan = FALSE) {
  out <- object$summary %>%
    filter(
      Type == {{ type }},
      x_var == {{ x_var }},
      Parameter %in% {{ parameters }}
    ) %>%
    # We can use the xintercept mapping to control alpha below
    ggplot(aes(Mean, Game)) +
    coord_cartesian(xlim = x_limits) +
    scale_x_continuous(
      "Estimated cross-lagged effect",
      breaks = pretty_breaks(7),
      expand = expansion(.01)
    ) +
    scale_y_discrete(
      expand = expansion(c(0.15, 0.25)),
      labels = function(x) ifelse(x == "Average", "**Average**", x)
    ) +
    scale_fill_brewer(
      palette = "Set1", direction = 1, aesthetics = c("fill", "color")
    ) +
    scale_alpha_manual(values = c(.4, .8)) +
    # Vertical line for 0
    geom_vline(xintercept = 0, size = .1, col = "grey60") +
    # Posterior densities
    stat_halfeye(
      data = object$draws %>%
        filter(
          Type == {{ type }},
          x_var == {{ x_var }},
          Parameter %in% {{ parameters }}
        ),
      aes(
        value,
        fill = stat(x > 0),
        alpha = Game == "Average"
      ),
      height = .75, adjust = 1.5, point_interval = NULL,
      show.legend = FALSE, normalize = "panels"
    ) +
    # Summary geoms and texts
    geom_pointrangeh(
      aes(x = Mean, xmin = CI_low, xmax = CI_high),
      size = .2, fatten = 1.25, position = position_nudge(y = -.01)
    ) +
    # CIs in right margin
    geom_text(
      vjust = -0.5, size = 3, hjust = 1,
      aes(x = x_limits[2], label = Res),
      family = Font
    ) +
    # Posterior probability of direction for average
    geom_text(
      data = object$summary %>%
        filter(Game == "Average") %>%
        filter(
          Type == {{ type }},
          x_var == {{ x_var }},
          Parameter %in% {{ parameters }}
        ),
      vjust = 1.4, size = 3,
      aes(
        x = sign(Mean) * 0,
        hjust = ifelse(sign(Mean) == 1, 0, 1),
        label = str_glue("{percent(pd, .1)}"),
        col = as.logical(sign(Mean) == 1)
      ),
      family = Font,
      show.legend = FALSE
    ) +
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_markdown(),
      # panel.grid.major.y = element_blank()
    ) +
    facet_wrap("Panel_label", scales = "free_x", labeller = label_parsed)
  
  # Also display lavaan game-specific estimates?
  if (lavaan) {
    out +
      geom_pointrangeh(
        data = d_ma %>%
          filter(
            Type == {{ type }},
            x_var == {{ x_var }},
            Parameter %in% {{ parameters }}
          ) %>%
          left_join(Order),
        col = "gray40", fatten = 1.25, size = .33,
        aes(x = est, xmin = ci.lower, xmax = ci.upper),
        position = position_nudge(y = -.075)
      )
  } else {
    out
  }
}
```

```{r forest-hours-wb, fig.width = 8, fig.height = 5, fig.cap = "Forest plots of meta-analytic raw cross-lagged regression coefficients from models examining average hours played per day and well-being. Shaded curves indicate approximate posterior densities, which are numerically summarised by means and 95%CIs in the right margin. Numbers below average effects indicate posterior probabilities of direction."}
fit_ma_sum <- summarize_ma(fit_ma)
fp_1 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Hours",
  parameters = c("wy2 ~ wx1"),
  lavaan = FALSE,
  x_limits = c(-.3, .4)
)
fp_2 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Hours",
  parameters = c("wx2 ~ wy1"),
  lavaan = FALSE,
  x_limits = c(-.05, .075)
)
(fp_1 + theme(axis.title.x = element_blank())) / fp_2
```

```{r forest-hours-wb-lavaan, fig.width = 8, fig.height = 5, fig.cap = "Figure as above but also displaying the underlying lavaan fits' point estimates and 95%CIs."}
# Also see in comparison to lavaan model estimates
forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Hours",
  parameters = c("wy2 ~ wx1", "wx2 ~ wy1"),
  lavaan = TRUE
)
```

### Experiences <-> WB

```{r forest-motivations-wb-1, fig.width = 8, fig.height = 5, fig.cap = "Forest plots of meta-analytic raw cross-lagged regression coefficients from models examining motivations and well-being (motivations to well-being). Shaded curves indicate approximate posterior densities, which are numerically summarised by means and 95%CIs in the right margin. Numbers below average effects indicate posterior probabilities of direction."}
fp_1 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Intrinsic",
  parameters = c("wy2 ~ wx1"),
  lavaan = FALSE,
  x_limits = c(-.2, .5)
) +
  theme(axis.title.x = element_blank())
fp_2 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Intrinsic",
  parameters = c("wx2 ~ wy1"),
  lavaan = FALSE,
  x_limits = c(-.1, .3)
) +
  theme(axis.title.x = element_blank())
fp_3 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Extrinsic",
  parameters = c("wy2 ~ wx1"),
  lavaan = FALSE,
  x_limits = c(-.4, .3)
) +
  theme(axis.title.x = element_blank())
fp_4 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Extrinsic",
  parameters = c("wx2 ~ wy1"),
  lavaan = FALSE,
  x_limits = c(-.4, .3)
)
fp_1 / fp_3
```

```{r forest-motivations-wb-2, fig.width = 8, fig.height = 5, fig.cap = "Forest plots of meta-analytic raw cross-lagged regression coefficients from models examining motivations and well-being (well-being to motivations). Shaded curves indicate approximate posterior densities, which are numerically summarised by means and 95%CIs in the right margin. Numbers below average effects indicate posterior probabilities of direction."}
fp_2 / fp_4
```

### Autocorrelations

```{r forest-autocorrelations, fig.width = 8, fig.height = 4, fig.cap = "Forest plots of meta-analytic raw lagged regression coefficients from models examining average hours played and well-being, showing only the well-being autocorrelations. Shaded curves indicate approximate posterior densities, which are numerically summarised by means and 95%CIs in the right margin. Numbers below average effects indicate posterior probabilities of direction."}
forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "Hours",
  parameters = c("wy2 ~ wy1"),
  lavaan = TRUE,
  x_limits = c(-.2, .6)
) +
  scale_x_continuous(
    "Estimated lagged effect",
    breaks = pretty_breaks()
  )
```

### Some post-hoc calculations

The model parameters report effects of one-unit (e.g. one hour per day) changes in the predictor on the outcome. We also expand on this by first asking what is the effect of an average deviation in a predictor on the outcome. That is, for example, we calculate the average range of players' average daily hours played, and then answer what the effect of an average player moving from their smallest to greatest amount of play would be on well-being.

```{r}
# Average ranges of predictors
avg_ranges <- d %>%
  # Calculate range for everyone (returns -Inf if all values missing)
  group_by(Game, pid) %>%
  summarise(
    across(
      c(Intrinsic, Extrinsic, Hours, hours_est),
      .fns = ~max(.x, na.rm = TRUE) - min(.x, na.rm = TRUE)
    )
  ) %>% 
  ungroup() %>% 
  # Calculate grand mean range excluding -Inf values
  summarise(
    across(
      Intrinsic:hours_est, 
      ~mean(if_else(.x==-Inf, NaN, .x), na.rm = TRUE)
    )
  ) %>% 
  pivot_longer(
    everything(),
    names_to = "x_var",
    values_to = "Mean_range"
  )
fit_ma %>%
  filter(
    Type == "Unstandardized",
    Parameter == "wy2 ~ wx1"
  ) %>%
  left_join(avg_ranges) %>% 
  mutate(
    hypothesis = map2(
      fit,
      Mean_range,
      ~ hypothesis(.x, str_glue("Intercept * {.y} = 0")) %>% .[[1]]
    )
  ) %>%
  unnest(hypothesis) %>%
  select(x_var, y_var, Mean_range, Parameter, Estimate:CI.Upper) %>%
  kbl(digits = 3, caption = "ES of average hours per week on WB") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

We then turn to a second question, how much would the average player need to increase their play to result in a subjectively noticeable effect. Anvari and Lakens estimated that a 2% movement might be a lower limit to a subjectively noticeable change in well-being using a similar measurement scale. 

We calculate, for each predictor and outcome, how much the predictor would need to change in order to elicit a change in the outcome greater than the subjective threshold. e.g. How many more hours would one need to play to "feel it".

```{r}
# Subjective threshold for each outcome
subjective_thresholds <- tibble(
  y_var = c("Affect", "Life satisfaction"),
  Threshold = 0.02 * c(13, 11)
)

# Table of effects and thresholds
fit_ma_sum$summary %>% 
  filter(
    Type == "Unstandardized",
    Parameter == "wy2 ~ wx1",
    Game == "Average"
  ) %>% 
  select(x_var, y_var, Effect = Mean) %>% 
  arrange(x_var, y_var) %>% 
  left_join(subjective_thresholds) %>% 
  mutate(`Change needed` = Threshold / abs(Effect)) %>% 
  kbl(
    digits = 2, 
    caption = "Estimated required change in X to elicit a subjectively noticeable change in well-being outcomes"
  ) %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

How much of posterior density is within ROPE defined by A&L subjectively noticeable limits?

```{r}
# Table of percentages of effects' posterior distributions with ROPE (as defined by thresholds for being subjectively noticed)
fit_ma %>%
  filter(
    Parameter == "wy2 ~ wx1",
    Type == "Unstandardized"
  ) %>%
  left_join(subjective_thresholds) %>% 
  mutate(
    out = map2(
      fit,
      Threshold,
      ~ describe_posterior(.x, rope_range = c(-.y, .y), rope_ci = 1) %>%
        select(-Parameter)
    )
  ) %>%
  unnest(out) %>%
  select(x_var, y_var, Threshold, CI_low, CI_high, ROPE_Percentage) %>%
  mutate(ROPE_Percentage = percent(ROPE_Percentage, .1)) %>%
  kbl(
    digits = 2,
    caption = "ROPE percentages below threshold"
  ) %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

## Subjective time

Comparing subjective hours estimates to objective play behaviour is complicated by the fact that a missing value in objective behaviour indicates zero hours of play, whereas a missing value in estimated time can indicate either an estimated lack of play, or a missing response (e.g. player declined to respond to this item). Therefore any comparison here is done only on individuals who provided subjective estimate data.

Histograms of hours played (behaviour: top, strong; estimated: bottom, light). Only person-waves with both variables present are included.

```{r time-subjective-objective-histogram, fig.height = 7, fig.width = 8, fig.cap = "Bivariate histograms of average hours played per day by wave (columns) and game (rows). Histograms above zero, with strong colour, reflect behavioural telemetry log data. Histograms below zero, in light colour, indicate subjective estimates of play. Histogram heights are normalized counts. Small triangles indicate means."}
tmp <- d %>%
  drop_na(Hours, hours_est) %>%
  group_by(Game, pid, Wave) %>%
  summarise(
    Hours = sum(Hours, na.rm = T),
    hours_est = sum(hours_est, na.rm = T)
  ) %>%
  group_by(Game, Wave) %>%
  summarise(
    across(c(Hours, hours_est), .fns = list(m = mean, se = ~ sd(.x) / sqrt(length(.x))))
  )

d %>%
  select(Game, pid, Wave, Hours, hours_est) %>%
  drop_na(Hours, hours_est) %>%
  filter(Hours < 3, hours_est < 3) %>%
  ggplot(aes()) +
  scale_y_continuous(
    "Normalised count",
    breaks = pretty_breaks()
  ) +
  scale_x_continuous(breaks = pretty_breaks()) +
  geom_histogram(
    aes(x = Hours, y = stat(ncount)),
    bins = 30, fill = col1, col = "white", alpha = .75
  ) +
  geom_histogram(
    aes(x = hours_est, y = stat(ncount) * -1),
    bins = 30, fill = col1, col = "white", alpha = .5
  ) +
  geom_pointrangeh(
    data = tmp, shape = 25, fill = col1, alpha = 1,
    aes(
      x = Hours_m,
      xmin = Hours_m - Hours_se,
      xmax = Hours_m + Hours_se,
      y = .075,
    )
  ) +
  geom_pointrangeh(
    data = tmp, shape = 24, fill = col1, alpha = .75,
    aes(
      x = hours_est_m,
      xmin = hours_est_m - hours_est_se,
      xmax = hours_est_m + hours_est_se,
      y = -.075
    )
  ) +
  facet_grid(Game ~ Wave, scales = "free")
```

A scatterplot of subjective on objective time. Only person-waves with both variables present are included.

```{r time-subjective-objective-scatterplot, fig.height = 7, fig.width = 8, fig.cap = "Scatterplots of subjectively estimated average hours of daily play on objective behavioural hours played. Dashed line indicates identity, solid lines are simple regression lines. Small blue points are individual participants, and solid dark points are bivariate sample means."}
d %>%
  drop_na(Hours, hours_est) %>%
  filter(Hours < 3, hours_est < 3) %>%
  select(Game, pid, Wave, Objective = Hours, Subjective = hours_est) %>%
  ggplot(aes(Objective, Subjective)) +
  scale_x_continuous(
    "Hours played per day (behaviour)",
    breaks = c(0, 1, 2, 3), labels = c(0, 1, 2, 3)
  ) +
  scale_y_continuous(
    "Hours played per day (estimate)",
    breaks = pretty_breaks()
  ) +
  geom_point(size = .2, alpha = .2, shape = 1, col = col1) +
  geom_abline(intercept = 0, slope = 1, lty = 2, size = .25) +
  stat_centroid() +
  geom_smooth(
    method = "lm", size = .4,
    color = "black",
    alpha = .33, show.legend = FALSE
  ) +
  facet_grid(Wave ~ Game) +
  theme(aspect.ratio = 1)
```

Wave-person differences. Difference indicates estimate - behaviour, so positive numbers indicate overestimates.

```{r time-subjective-objective-differences, fig.height = 6, fig.width = 6, fig.cap = "Density curves of differences between subjectively estimated and objectively loggeed average daily play time."}
d %>%
  select(Game, pid, Wave, Hours, hours_est) %>%
  mutate(Difference = hours_est - Hours) %>%
  filter(Hours < 3, hours_est < 3) %>%
  drop_na(Difference) %>%
  ggplot(aes(Difference, Game)) +
  scale_x_continuous(
    "Estimation error (hours/day)",
    breaks = pretty_breaks()
  ) +
  coord_cartesian(xlim = c(-1.5, 1.5)) +
  geom_vline(xintercept = 0, lty = 2, size = .25) +
  stat_halfeye(point_interval = NULL) +
  stat_summaryh(fun.data = mean_cl_boot_h) +
  facet_wrap("Wave", ncol = 1)

# Overall confidence interval for estimation error
d %>%
  select(Game, pid, Wave, Hours, hours_est) %>%
  mutate(Difference = hours_est - Hours) %>%
  filter(Hours < 3, hours_est < 3) %>%
  drop_na(Difference) %>%
  group_by(Wave) %>%
  summarise(mean_cl_boot(Difference)) %>%
  kbl(digits = 2, caption = "Estimation errors (Estimated - Behaviour)") %>% 
  kable_styling(full_width = FALSE, font_size = 12)
```

### Meta-analysis

```{r forest-subjective-wb, fig.width = 8, fig.height = 5, fig.cap = "Forest plots of meta-analytic raw cross-lagged regression coefficients from models examining subjectively estimated average hours played per day and well-being. Shaded curves indicate approximate posterior densities, which are numerically summarised by means and 95%CIs in the right margin. Numbers below average effects indicate posterior probabilities of direction."}
fp_1 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "hours_est",
  parameters = c("wy2 ~ wx1"),
  lavaan = TRUE,
  x_limits = c(-.3, .5)
)
fp_2 <- forest_plot(
  object = fit_ma_sum,
  type = "Unstandardized",
  x_var = "hours_est",
  parameters = c("wx2 ~ wy1"),
  lavaan = TRUE,
  x_limits = c(-.1, .1)
)
fp_1 / fp_2
```

## System information

```{r}
sessionInfo()
```
