---
title: "Deal with overlapping sessions"
author: "Kristoffer Magnusson"
date: "`r Sys.Date()`"
output: html_document
---

```{r packages, results = 'hide'}
library(knitr)
library(tidyverse)
library(here)
```

```{r}

#' Check if int1 and int2 intersect
#' if they intersect:
#'      - set int1 to union of int1 & int2
#'      - set int2 to NA
#' if not intersect:
#'      - return original intervals
#' 
#' @return vector of int1, int2
merge_interval <- function(int2, int1) {
    if(!is.na(intersect(int1, int2))) {
        int1 <- union(int1, int2)
        int2 <- as.interval(NA)
        out <- c(int1, int2)
    } else {
        out <- c(int1, int2)
    }

    out
}

# Merge all overlapping intervals in df
merge_intervals_df <- function(data) {
    data$interval2 <- data$interval
    for(i in 1:nrow(data)) {
        int1 <- data$interval2[i]
        if(is.na(int1)) next
        if(i < nrow(data)) {
            for(j in (i + 1):nrow(data)) {
                cat("i: ", i, ", j: ", j, "\n")
                int2 <- data$interval2[j]
                merged <- merge_interval(int2, int1)
                int1 <- merged[1]
                data$interval2[i] <- int1
                data$interval2[j] <- merged[2]
        }
        }
    }
    data
}

```


## Reprex
Let's start with a reproducible example to see if the function can handle both overlapping and separate session.
```{r}
tmp <- data.frame(
    interval = c(
        interval(
            as_datetime("2011-12-31 12:00:00"), 
            as_datetime("2011-12-31 14:00:00")
            ), 
        interval(
            as_datetime("2011-12-31 13:00:00"), 
            as_datetime("2011-12-31 14:00:00")
        ),
        interval(
            as_datetime("2011-12-31 13:30:00"), 
            as_datetime("2011-12-31 16:00:00")
        ),
        interval(
            as_datetime("2011-12-31 16:30:00"), 
            as_datetime("2011-12-31 17:00:00")
        ),
        interval(
            as_datetime("2011-12-31 11:00:00"), 
            as_datetime("2011-12-31 11:30:00")
        )
    )
) %>% mutate(
    session_start = int_start(interval),
    session_end = int_end(interval)
    )
```


```{r, results = FALSE, message = FALSE}
tmp <- merge_intervals_df(tmp)
```


The plot looks correct.
```{r, echo = FALSE}
plot_compare <- function(data) {
    data <- data %>% mutate(
        session_start2 = int_start(interval2),
        session_end2 = int_end(interval2)
        )

    data %>% 
    rowid_to_column() %>% 
    ggplot(aes(session_start, rowid)) +
    geom_segment(
        aes(
            xend = session_end, 
            yend = rowid,
            color = "original"
            )
        ) +
    geom_segment(
        aes(
            x = session_start2, 
            xend = session_end2, 
            yend = rowid,
            color = "merged"
            ), 
            position = position_nudge(y = 0.5)
        ) +
        scale_color_manual(values = c("red", "black"))
}
plot_compare(tmp)
```

## Real data

Now let's try with real data. The object is from `01_clean.Rmd`.
```{r}
d_t <- read_rds(here("Data/overlap_example.Rds"))
```

Merge and plot
```{r, results = FALSE, message = FALSE}
tmp <- d_t %>% 
  arrange(session_start, session_end) %>% 
  filter(pid == "de9b7f238ba168b0", session_start < "2021-07-5") 

tmp <- merge_intervals_df(tmp)
plot_compare(tmp)
```

The merged intervals looks correct.